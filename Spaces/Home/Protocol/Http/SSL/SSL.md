## Secure Sockets Layer


![[SSL2.png]]

우선, HTTPS와 SSL은 다릅니다. SSL과 TLS는 '보안 계층'이라는 독립적인 프로토콜 계층을 만들어, 위 그림과 같이 응용 계층과 전송 계층 사이에 속하게 됩니다. HTTPS는 SSL 또는 TLS 위에 HTTP 프로토콜을 얹어 보안된 HTTP 통신을 하는 프로토콜입니다. 즉, SSL과 TLS는 HTTP뿐만이 아니라 FTP, SMTP와 같이 다른 프로토콜에도 적용할 수 있으며, HTTPS는 TLS와 HTTP가 조합된 프로토콜만을 가리키는 겁니다. SSL과 TLS는 같은 의미의 단어입니다. TLS가 SSL의 후속 버전이지만, SSL이 일반적으로 더 많이 사용되는 용어입니다.




> **“이제 SSL 암호화 통신에 대해 어느 정도 이해가 갑니다. 그럼 어떤 식으로 보안이 적용되는 건가요?”**

SSL 암호화 통신은 여러 가지 조건과 과정을 통해 설립됩니다. 앞에서 언급한 이야기는 아주 간단한 예시입니다. 먼저, 통신 과정들을 알아보겠습니다. SSL 암호화 통신은 총 세 단계로 나눌 수 있습니다.

![[SSL1.png]]

첫 번째로, SSL 핸드셰이크를 수행합니다. 이때 데이터를 주고받기 위해 어떤 방법을 사용해야 하는지 서로의 상태를 파악합니다. SSL은 80번 포트를 사용하는 http와 달리 443번 포트를 기본으로 사용하는 TCP 기반의 프로토콜입니다. TCP 기반이기 때문에 SSL 핸드셰이크 전에 TCP 3-way 핸드셰이크 또한 수행합니다. 서로 간 협상이 완료되면, SSL 세션이 생성되고 클라이언트와 서버는 원하는 데이터를 주고받게 됩니다. 그리고 데이터 전송의 끝을 서로에게 알리며 세션을 종료합니다.

**핸드셰이크 단계에선 서로 어떤 것들을 협상하게 되나요?**


![[SSL3.png]]


서로 간의 메시지와 데이터 통신은 사람과 사람이 대화하는 것과 유사합니다. TCP 통신의 바탕인 '신뢰성'을 생각하면 더욱 쉽게 이해할 수 있을 겁니다.

​
- Client hello : 클라이언트가 서버에게 연락합니다. 브라우저 검색창에 도메인을 입력하는 것으로 보면 됩니다. 이때 클라이언트는 자신의 브라우저가 지원할 수 있는 암호화 방식(Cipher Suite)을 먼저 제시합니다. 그리고 랜덤 데이터를 생성하여 추가로 전송합니다.

- Server hello : 서버가 클라이언트에게 연락합니다. 서버는 클라이언트가 제시한 암호화 방식 중 하나를 선정하여 알려줍니다. 또한, 서버 자신의 인증서를 전달합니다. 이 인증서에는 서버의 공개 키가 포함되어 있습니다. 클라이언트와 마찬가지로 서버 측에서 생성한 랜덤 데이터 또한 전달합니다.

- Client key exchange : 클라이언트는 미리 주고받은 자신과 서버의 랜덤 데이터를 참고하여 서버와 암호화 통신을 할 때 사용할 키를 생성한 후 서버에게 전달합니다. 이때 키는 서버로부터 받은 공개키로 암호화되어 보내집니다.

- Finished : 마지막으로 핸드셰이크 과정이 정상적으로 마무리되면, 클라이언트와 서버 모두 “finished” 메시지를 보냅니다. 그 후부턴 클라이언트가 생성한 키를 이용하여 암호화된 데이터를 주고받게 됩니다.



**3. SSL 인증서**

SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서입니다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달하게 됩니다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 됩니다.



![[SSL4.png]]


**SSL과 SSL 디지털 인증서를 이용했을 때의 이점은 아래와 같습니다.**

 - 통신 내용이 공격자에게 노출되는 것을 막을 수 있습니다.

 - 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지를 판단할 수 있습니다.

 - 통신 내용의 악의적인 변경을 방지할 수 있습니다.

  

**SSL 인증서의 역할**

SSL 인증서의 역할은 다소 복잡하기 때문에 인증서의 매커니즘을 이해하기 위한 몇가지 지식들을 알고 있어야 합니다. 인증서의 기능은 크게 두가지가 있습니다. 아래 두가지를 이해하는 것이 인증서를 이해하는 핵심입니다.

  

> 1. 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장합니다.
> 
> 2. SSL 통신에 사용할 공개키를 클라이언트에게 제공합니다.

  

**CA**

**인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할**을 합니다. 이 역할을 하는 민간기업들이 있는데 이런 기업들을 CA(Certificate authority) 혹은 Root Certificate 라고 부릅니다. CA는 아무 기업이나 할 수 있는 것이 아니고 신뢰성이 엄격하게 공인된 기업들만 참여할 수 있습니다.




![[SSL5.jpg]]




#### 1. 서버는 공개키와 개인키를 만든다.

#### 2. 믿을만한 저장소(CA)와 계약해 두 키를 관리하도록 한다.

#### 3.  CA도 자신만의 공개키와 개인키를 가지고 자체 암호화를 하여 SSL 인증서를 발급한다.

#### 4. 클라이언트의 데이터 요청이 들어오면 서버는 CA에서 만든 SSL 인증서를 보내준다.

#### 5. 클라이언트는 CA의 공개키를 이용해 SSL 인증서를 복호화(암호 해독)한다.

#### 6. SSL 내부의 서버 공개키를 이용해서 암호화해서 인증서를 서버에게 보낸다.

#### 7. 서버는 개인키로 암호화된 인증서를 복호화(암호 해독)하고 다시 암호화 하여 클라이언트에게 보낸다.



## 실제로 적용시키는 방

윈도우 기준

[https://sourceforge.net/projects/openssl/files/latest/download?source=typ_redirect](https://sourceforge.net/projects/openssl/files/latest/download?source=typ_redirect)

사이트에 들어가서 .zip 파일을 다운받고 C드라이브 아래에 다운해준다. 물론 자기가 원하는 위치에 다운해도 된다! 대신 중간에 생기는 오류는 내가 해결해줄수 없다...ㅎ C드라이브 아래에 압축을 풀어주고 bin 폴더로 들어가자

window의 경우 openssl.exe가 있는데 이를 실행시켜준다!

여기서 가장 중요한 사항은 그냥 실행시키면 안된다! 무조건 관리자 권한으로 실행시켜주자





![[SSL6.png]]


이걸 몰라서 파일이 정상적으로 만들어지지 않아 오류가 생길수 있다!

이제 ssl 인증을 위한 파일들을 순서대로 만들어볼 차례다!

(파일들은 모두 openssl 실행한 폴더 내부에 생성되어집니다.)

### **1. 개인키, 공개키 발급**

실행된 cmd창에서

**genrsa -des3 -out private.pem 2048**

genrsa \[암호화 알고리즘] -out \[파일이름].pem 2048

명령어를 실행해준다.

[] 안에 내용은 사용자가 원하는대로 변경해서 사용해도 된다.

 다음 내용들도 알아서 맞게 변경


![[Pasted image 20240112175545.png]]



---
참조 - https://blog.naver.com/skinfosec2000/222135874222
https://12bme.tistory.com/80


https://namjackson.tistory.com/24


https://ililil9482.tistory.com/114

https://ililil9482.tistory.com/115