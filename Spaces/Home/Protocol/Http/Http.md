### **WWW(World Wide Web, 월드 와이드 웹)의 발명**

- WWW란 웹 페이지를 네트워크 상에서 이용하기 위한 구조를 말한다.
- WWW는 실험실에서 파일을 교환하기 위해 1989년부터 1991년에 발명되었다.
- WWW에서는 HTTP라는 통신방식(프로토콜)에 기초하여 주고받기가 실행된다.
- WWW 발명으로 HTTP 프로토콜이 개발되었고 또 발전하였다.
- WWW는 네 개로 구성되어있다.
- 첫 째. 하이터텍스트 문서를 표한하기 위한 텍스트 형식의 언어 및 파일인 HTML
- 둘 째. 인터넷 상에서 문서 등을 교환하기 위한 프로토콜인 HTTP
- 셋 째. 문서를 디스플레이하기 위한 웹 브라우저 (HTML 렌더링 등 현재는 더 많은 일을 한다.)
- 마지막. 문서에 접근하도록 해주는 HTTPD(HyperText Transfer Protocol Daemon)의 초기 버전, 즉 HTTP를 지원하는 서버 (웹 서버를 구축하다는 말은 HTTPD를 수행시킨다는 말과 같다.)

### **👉 웹(Web)이란?**

- 웹(Web)이란 World Wide Web, 월드 와이드 웹의 약자이다.
- 인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간을 의미한다.
- 인터넷과 동의어가 아니다.
- 웹 브라우저를 통해 서버와 클라이언트가 통신하는 방식의 인터넷 서비스 중 하나이다.



# HTTP이란?

HTTP(Hypertext Transfer Protocol)는 인터넷상에서 데이터를 주고 받기 위한 **서버/클라이언트 모델**을 따르는 프로토콜이다.

애플리케이션 레벨의 프로토콜로 **TCP/IP위에서 작동**한다.

HTTP는 **어떤 종류의 데이터든지 전송**할 수 있도록 설계돼 있다. 

HTTP로 보낼 수 있는 데이터는 **HTML문서, 이미지, 동영상, 오디오, 텍스트 문서** 등 여러종류가 있다.

하이퍼텍스트 기반으로(Hypertext) 데이터를 전송하겠다(Transfer) = **링크기반으로 데이터에 접속**하겠다는 의미이다.

![[HTTP1.webp]]



![[HTTP2.webp]]




## HTTP 동작

클라이언트 즉, 사용자가 브라우저를 통해서 어떠한 서비스를 url을 통하거나 다른 것을 통해서 요청(request)을 하면 서버에서는 해당 요청사항에 맞는 결과를 찾아서 사용자에게 응답(response)하는 형태로 동작한다.

- 요청 : client -> server
- 응답 : server -> client

HTML 문서만이 HTTP 통신을 위한 유일한 정보 문서는 아니다.  
Plain text로 부터 JSON 데이터 및 XML과 같은 형태의 정보도 주고 받을 수 있으며, 보통은 클라이언트가 어떤 정보를 HTML 형태로 받고 싶은지, JSON 형태로 받고 싶은지 명시해주는 경우가 많다.


## HTTP 특징

- HTTP 메시지는 HTTP 서버와 HTTP 클라이언트에 의해 해석이 된다.
- TCP/ IP를 이용하는 응용 프로토콜이다.  
    (컴퓨터와 컴퓨터간에 데이터를 전송 할 수 있도록 하는 장치로 인터넷이라는 거대한 통신망을 통해 원하는 정보(데이터)를 주고 받는 기능을 이용하는 응용 프로토콜)
- HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다.  
    (이러한 단점을 해결하기 위해 Cookie와 Session이 등장하였다.)
- HTTP는 연결을 유지하지 않는 프로토콜이기 때문에 요청/응답 방식으로 동작한다.
- HTTP 기본적으로 **request**(요청)/**response**(응답) 구조로 되어있다.  
	클라이언트가 HTTP request를 서버에 보내면 서버는 HTTP response를 보내는 구조  
	클라이언트와 서버의 모든 통신이 요청과 응답으로 이루어 진다.
	
	![[HTTP3.png]]



**👉 무상태 프로토콜 (Stateless)**  
무상태 프로토콜은 웹 서버가 웹 클라이언트의 상태 정보를 유지하지 않는 것을 의미하며, 상태 정보는 브라우저가 서버에게 요청을 전달하면서 함께 전달한 데이터를 의미한다. HTTP는 기본적으로 상태 정보를 유지하지 않기 때문에 상태 정보 유지가 필요한 작업에서 쿠키(Cookie)나 세션(Session)을 이용하여 상태를 유지한다.   
  
**👉 비연결성 (Connectionless)**  
비연결성은 브라우저가 서버에 요청하는 순간 잠깐 서버와 연결됐다가 서버로부터 응답이 전송된 후 곧바로 연결이 끊기는 것을 의미한다. 웹 환경상 다수의 브라우저가 서버와 통신하기 때문에 만약 브라우저와 서버가 지속적으로 연결된 상태를 유지한다면 다른 브라우저와 연결하는데 문제가 생길 수 있다.




### 예시로 알아보는 HTTP
- **서버** : 어떠한 자료에 대한 접근을 관리하는 네트워크 상의 시스템 **(요청에 대한 응답을 보내준다.)**
- **클라이언트** : 그 자료에 접근할 수 있는 프로그램  
    Ex) 웹 브라우저, 핸드폰 어플리케이션 등..




## HTTP 프로토콜

### HTTP 프로토콜의 특징

**HyperText Transfer Protocol(하이퍼 텍스트 전송 프로토콜)**  
HyperText

www에서 쓰이는 핵심 프로토콜로 문서의 전송을 위해 쓰이며, 오늘날 거의 모든 웹 애플리케이션에서 사용되고 있다.  
➡️음성, 화상 등 여러 종류의 데이터를 MIME로 정의하여 전송 가능

#### HTTP 특징

`Request` / `Response` (요청/응답) 동작에 기반하여 서비스 제공

#### HTTP 1.0의 특징

"연결 수립, 동작, 연결 해제"의 단순함이 특징  
➡️하나의 URL은 하나의 TCP 연결  
HTML 문서를 전송 받은 뒤 연결을 끊고 다시 연결하여 데이터를 전송한다.

#### HTTP 1.0의 문제점

단순 동작(연결 수립, 동작, 연결 해제)이 반복되어 통신 부하 문제 발생  
ex) 네이버 메인 페이지에 그림이 1개 있으면 연결,동작,해제가 10번 반복됨

![[HTTP4.png]]


#### HTTP 1.1의 특징

HTTP 1.0과 호환 가능  
Multiple Request 처리가 가능하여 Client의 Request가 많을 경우  
연속적인 응답 제공 ➡️ Pipeline 방식의 Request/Response 진행

HTTP 1.0과는 달리 Server가 갖는 하나의 IP Address와 다수의 Web Site 연결 가능

#### HTTP 1.1

빠른 속도와 Internet Protocol 설계에 최적화될 수 있도록 Cache 사용  
Data를 압축해서 전달이 가능하도록 하여 전달하는 Data 양이 감소

![[HTTP6.png]]


# #Request (요청)

**클라이언트가 서버에게 연락하는 것**을 요청이라고 하며 요청을 보낼 때는 요청에 대한 정보를 담아 서버로 보낸다.

## 예시로 알아보는 Request

서버가 주문서를 받아 클라이언트가 어떤 것을 원하는지 파악할 수 있게 한다. 이처럼 **요청은 식당에서 주문서를 작성하는 것과 같다**고 생각하면 된다.

## Request Method (요청의 종류)

- **GET** : 자료를 **요청**할 때 사용
- **POST** : 자료의 **생성**을 요청할 때 사용
- **PUT** : 자료의 **수정**을 요청할 때 사용
- **DELETE** : 자료의 **삭제**를 요청할 때 사용
- **HEAD** : 주어진 URL에서 자원의 헤더만을 요청, 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다.
- **OPTIONS** : 주어진 URL에서 처리 가능한 메소드의 목록을 요청

## Request HTTP 메시지 예시

```null
GET https://velog.io/@surim014 HTTP/1.1								// 시작줄
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...			  // 헤더
Upgrade-Insecure-Requests: 1
```


![[HTTP7.png]]




### 1. 시작줄 (첫 줄)

첫 줄은 시작줄로 **메서드 구조 버전**으로 구성되었다.

- GET : HTTP Method
- https://naver.com : 사이트 주소
- HTTP/1.1 : HTTP 버전

### 2. 헤더 (두 번째 줄부터)

두번째 줄부터는 헤더이며 **요청에 대한 정보**를 담고 있다. User-Agent, Upgrade-Insecure-Requests 등등이 헤더에 해당되며 헤더의 종류는 매우 많다.

### 3. 본문 (헤더에서 한 줄 띄고)

본문은 **요청을 할 때 함께 보낼 데이터를 담는 부분**이다. 현재 예시에는 단순히 주소로만 요청을 보내고 있고 따로 데이터를 담아 보내지 않기 때문에 본문이 비어있다.

# #Response (응답)

**서버가 요청에 대한 답변을 클라이언트에게 보내는 것**을 응답이라고 한다.

![[HTTP8.png]]

## #Status Code (상태 코드)

**HTTP Status 코드**라고 불리기도 하며 **서버가 응답을 전송할 때 같이 전송하는 코드**
**3자리 숫자**로 이루어져 있으며 요청에 대한 서버의 상태를 나타냄.
**앞 자리는 1~5의 숫자 중 하나**이며 **이 중 4와 5는 비정상적인 상황, 즉 오류가 있음을 의미**
상태 코드에는 굉장히 많은 종류가 있다. 모두 숫자 세 자리로 이루어져 있으며, 아래와 같이 크게 다섯 부류로 나눌 수 있다.
 
#### - **1XX (조건부 응답)** : 요청을 받았으며 작업을 계속한다.

**· 100 Continue** : 현재 요청이 진행중이며 문제 없다는 것을 의미합니다.

​

#### **2XX (성공)** : 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킨다.

**· 200 OK** : 요청이 성공적으로 완료되었음을 의미합니다.

**· 201 Created** : 요청이 성공적으로 완료되었고 새로운 리소스가 생성되었음을 의미합니다. 보통 POST아니면 PUT 요청 뒤에 따라옵니다.

​

#### **3XX (리다이렉션 완료)** : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.

**· 300 Multiple Choice** : 요청에 대해 하나 이상의 응답이 가능함을 의미합니다.

**· 301 Moved Permanently** : 요청한 리소스의 URI가 변경되었음을 의미합니다.

**​**

#### **4XX (요청 오류)** : 클라이언트에 오류가 있음을 나타낸다.

**· 400 Bad Request** : 잘못된 문법으로 인해 서버가 요청을 이해하지 못했음을 의미합니다.

**· 401 Unauthorized** : 요청을 보낸 클라이언트가 인증되지 않았음을 의미합니다.

**· 403 Forbidden** : 요청을 보낸 클라이언트가 리소스에 접근할 권리가 없음을 의미합니다.

**· 404 Not Found** : 서버가 요청받은 리소스를 찾을 수 없음을 의미합니다.

**· 408 Request Timeout** : 요청 중 시간이 초과되었음을 의미합니다.


​

#### **5XX (서버 오류)** : 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.

**· 500 Internal Server Error** : 서버에 문제가 있지만 서버가 해당 문제를 처리할 줄 모름을 의미합니다.

**· 502 Bad Gateway** : 서버가 게이트웨이로부터 잘못된 응답을 받았음을 의미합니다.

**· 503** **Service Temporarily Unavailable** : 일시적으로 서버를 이용할 수 없음을 의미합니다. 보통 유지보수를 위해 서버를 잠시 중단시켰거나 과부하로 인한 다운이 원인입니다.

**· 504 Gateway Timeout** : 서버가 게이트웨이 역할을 하고 있으며 다른 서버로부터 적시에 응답을 받지 못했음을 의미합니다.

## Resonse HTTP 메시지 예시

```null
HTTP/1.1 200 OK														// 시작줄
Connection: keep-alive												 // 헤더
Content-Encoding: gzip												 
Content-Length: 35653
Content-Type: text/html;

<!DOCTYPE html><html lang="ko" data-reactroot=""><head><title...
```

### 1. 시작줄 (첫 줄)

첫 줄은 **버전 상태코드 상태메시지**로 구성되어 있다. 200은 성공적인 요청이었다는 뜻이다.

### 2. 헤더 (두 번째 줄부터)

두 번째 줄부터는 헤더로 **응답에 대한 정보를 담고 있다.**

### 3. 본문 (헤더 뒤부터)

응답에는 대부분의 경우 본문이 있다. 보통 데이터를 요청하고 응답 메시지에는 **요청한 데이터를 담아서 보내주기 때문이다. 응답 메시지에 HTML이 담겨 있는데 이 HTML을 받아 브라우저가 화면에 렌더링한다.**


---
![[HTTP9.png]]


HTTP 메시지의 요청과 응답은 유사한 구조를 가진다.

- Start line : 요청의 상태를 나타내며, 항상 첫 번째 줄에 위치한다.
- Status line : 응답의 상태를 나타내며, 항상 첫 번째 줄에 위치한다.
- HTTP headers : 요청을 지정하거나 메시지에 포함된 본문을 설명하는 헤더의 집합이다.
- empty line : 헤더와 본문을 구분하는 빈 줄이다.
- body : 요청과 관련된 데이터나 응답과 관련된 데이터 또는 문서를 포함한다. 요청과 응답의 유형에 따라 선택적으로 사용한다.

start line과 HTTP headers를 묶어 요청의 헤드(head),

status line과 HTTP headers를 묶어 응답의 헤드(head)라 한다.







---
참조 - https://velog.io/@hyemin0111/HTTP-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%B4%EB%9E%80

https://shlee0882.tistory.com/107


https://velog.io/@surim014/HTTP%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

https://surprisecomputer.tistory.com/54

https://tibetsandfox.tistory.com/18


https://mangkyu.tistory.com/98 - https

https://velog.io/@rhdmstj17/%EC%86%8C%EC%BC%93%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-%ED%95%9C-%EB%B2%88%EC%97%90-%EC%A0%95%EB%A6%AC-2  - 실시간 통신

  https://gusrb3164.github.io/web/2021/10/28/websocket-socket/
https://urmaru.com/7
https://velog.io/@stbpiza/%EC%9B%B9%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C
