
![[TCPUDP1.png]]

## **TCP vs UDP**

![[TCPUDP2.png]]




## *TCP*

TCP는 말 그대로 **전송 제어를 위한 작업을 해주는 역할**을 한다.


### TCP의 역할
TCP는 연결 지향적 프로토콜이다.

**※ 연결 지향적 프로토콜은  클라이언트와 서버가 연결된 상태에서 데이터를 주고받는 프로토콜을 의미한다.**

장치들 사이에 논리적인 접속을 성립하기 위해 연결을 설정해 신뢰성을 보장하는 연결형 서비스이다.

TCP는 네트워크에 연결된 컴퓨터에서 실행되는 프로그램 간에 **일련의 옥텟(데이터, 메시지, 세그먼트라는 블록 단위)을** **안정적으로, 순서대로, 에러 없이 교환**할 수 있게 한다.

**TCP의 특징**

**1. 연결형 서비스로 가상 회선 방식을 제공**

 - 가상 회선 방식을 제공한다는 것은 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정한다는 말이다.
- 3-way handshaking 과정을 통해 연결을 설정하고,
- 4-way handshaking 과정을 통해 연결을 해제한다.
- 3-way handshaking 과정은 발신지와 수신지 사이에 논리적인 접속(세션)을 성립하는 과정을 의미한다.


**2. 흐름 제어(Flow control)**

- 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지

**3. 혼잡 제어(Congestion control)**

- 네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지

**4. 높은 신뢰성을 보장**

- 신뢰성이 높은 전송을 하기 때문에 UDP보다 속도가 느림

**5. 전이중(Full-Duplex), 점대점(Point to Point) 방식**

- 전이중(Full-Duplex) : 전송이 양방향으로 동시에 일어날 수 있다.
- 점대점(Point to Point) : 각 연결이 정확히 2개의 종단점을 가지고 있다.





**TCP의 연결 과정 ( 3-way handshake)**

![[TCPUDP3.jpg]]
- **받을 대상 노드(호스트)가 서비스 가능(연결 가능) 상태인지 확인 및 연결을 수립하는 역할**
- **전송을 제어해주는 정보를 패킷에 추가해주는 역할**


- **Step 1 (SYN)**
    
    **클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다. (seq : x)**
    
    - 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - PORT 상태
        - Client : `CLOSED`- `SYN_SENT` 로 변함
        - Server : `LISTEN`
- **Step 2 (SYN + ACK)**
    
    **서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (seq : y, ACK : x + 1)**
    
    - 접속요청을 받은 Q가 요청을 수락했으며, 접속 요청 프로세스인 P도 포트를 열어달라는 메세지를 전송 (SYN-ACK signal bits set)
    - ACK Number필드를 Sequence Number + 1 로 지정하고 SYN과 ACK 플래그 비트를 1로 설정한 새그먼트 전송 (`Seq=y, Ack=x+1, SYN, ACK`)
    - PORT 상태
        - Client : `CLOSED`
        - Server : `SYN_RCV`
- **Step 3 (ACK)**
    
    **클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄**
    
    - 마지막으로 접속 요청 프로세스 P가 수락 확인을 보내 연결을 맺음 (ACK)
    - 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.
    - PORT 상태
        - Client : `ESTABLISED`
        - Server : `SYN_RCV` ⇒ ACK ⇒ `ESTABLISED`

*전이중 full-duplex 통신의 구성*
- Step 1, 2에서는 P→Q 방향에 대한 연결 파라미터(시퀀스 번호)를 설정하고 이를 승인한다.
- Step 2, 3에서는 Q→P 방향에 대한 연결 파라미터(시퀀스 번호)를 설정하고 이를 승인한다.



| 상태         | 설명                                                   |
| ------------ | ------------------------------------------------------ |
| CLOSED       | 연결 수립을 시작하기 전의 기본 상태 (연결 없음)        |
| LISTEN       | 포트가 열린 상태로 연결 요청 대기 중                   |
| SYN-SENT     | SYN을 요청한 상태                                      |
| SYN-RECEIVED | SYN 요청을 받고 상대방의 응답을 기다리는 중            |
| ESTABLISHED  | 연결 수립이 완료된 상태, 서로 데이터를 교환할 수 있다. |


**TCP의 연결 해제 과정 (4-way handshake)**
![[TCPUDP4.jpg]]

- **STEP1 (Client → Server : FIN(+ACK)**
    
    - 서버와 클라이언트가 연결된 상태에서 클라이언트가 close()를 호출하여 접속을 끊는다.(으려한다.)
    - 이때, 클라이언트는 서버에게 연결을 종료한다는 `FIN` 플래그를 보낸다.
        - 이때 FIN 패킷에는 실질적으로 ACK도 포함되어있다.
- **STEP2 (Server → Client : ACK)**
    
    - 서버는 FIN을 받고, 확인했다는 `ACK`를 클라이언트에게 보내고 자신의 통신이 끝날때까지 기다린다. (이상태가 TIME_WAIT 상태)
        - Server(수신자)는 ACK Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - 서버는 클라이언트에게 응답을 보내고 **`CLOSE_WAIT` 상태**에 들어갑니다. 그리고**아직 남은 데이터가 있다면 마저 전송을 마친 후에 close( )를 호출**
    - 클라이언트에서는 서버에서 ACK를 받은 후에 서버가 남은 데이터 처리를 끝내고 FIN 패킷을 보낼 때까지 기다리게 됩니다. (**`FIN_WAIT_2`)**
- **STEP3 (Server → Client : FIN)**
    
    - 데이터를 모두 보냈다면, 서버는 연결이 종료에 합의 한다는 의미로 `FIN` 패킷을 클라이언트에게 보낸 후에, 승인 번호를 보내줄 때까지 기다니는 `LAST_ACK` 상태로 들어간다.
- **STEP4 (Client → Server : ACK)**
    
    - 클라이언트는 FIN을 받고, 확인했다는 `ACK`를 서버에게 보낸다.
    - 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 `TIME_WAI`T을 통해 기다린다. (실질적인 종료과정 `CLOSED`에 들어가게 된다.)
        - 이때 `TIME_WAIT` 상태는 **의도치 않은 에러로 인해 연결이 데드락으로 빠지는 것을 방지**
        - 만약 에러로 인해 종료가 지연되다가 타임이 초과되면 `CLOSED`로 들어갑니다.
- 서버는 ACK를 받은 이후 소켓을 닫는다 (Closed)
    
- TIME_WAIT 시간이 끝나면 클라이언트도 닫는다 (Closed)


| 상태        | 설명                                                                                                                |
| ----------- | ------------------------------------------------------------------------------------------------------------------- |
| ESTABLISHED | 연결 수립이 완료된 상태, 서로 데이터를 교환할 수 있다.                                                              |
| FIN-WAIT-1  | 자신이 보낸 FIN에 대한 ACK를 기다리거나 상대방의 FIN을 기다린다.                                                    |
| FIN-WAIT-2  | 자신이 보낸 FIN에 대한 ACK를 받았고, 상대방의 FIN을 기다린다.                                                       |
| CLOSE-WAIT  | 상대방의 FIN(종료 요청)을 받은 상태. 상대방 FIN에 대한 ACK를 보내고 어플리케이션에 종료를 알린다.                   |
| LAST-ACK    | COLSE-WAIT 상태를 처리 후 자신의 FIN 요청을 보낸 후 FIN에 대한 ACK를 기다리는 상태.                                 |
| TIME-WAIT   | 모든 FIN에 대한 ACK를 받고 연결 종료가 완료된 상태. 새 연결과 겹치지 않도록 일정 시간 기다린 후 CLOSED로 전이 한다. |
| CLOSED      | 연결 수립을 시작하기 전의 기본 상태 (연결 없음)                                                                     |



## **UDP**




![[TCPUDP5.png]]


**UDP의 특징**

**1. 비연결형 서비스로 데이터그램 방식을 제공한다.**

- 데이터의 전송 순서가 바뀔 수 있다.

**2. 데이터 수신 여부를 확인하지 않는다.**

- TCP의 3-way handshaking과 같은 과정 X

**3. 신뢰성이 낮다.**

- 흐름 제어(flow control)가 없어서 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.

**4. TCP보다 속도가 빠르다.**

**5. 1:1 & 1:N & N:N 통신이 가능하다.**

(1). UDP는 비연결형 서비스이기 때문에, (2). 연결을 설정하고 해제하는 과정이 존재하지 않는다.

서로 다른 경로로 독립적으로 처리하며,  (3). 흐름 제어 또는 혼잡 제어와 같은 기능을 처리하지 않기에 (4). TCP보다 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만, 신뢰성 있는 데이터 전송을 보장하지 못한다.

UDP는 신뢰성보다는 연속성 있는 전송이 필요할 때 사용하는 프로토콜로 예를 들면, 실시간 서비스(streaming)에 자주 사용된다.








---
참조 - https://dev-coco.tistory.com/144
https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPUDP%EC%99%80-3-Way-Handshake4-Way-Handshake
