### Linux(리눅스)란?

Linux는 1991년 Linus Torvals가 개발한 운영체제이다. Linux는 Unix 운영체제를 기반으로 만들어진 운영체제로 유닉스 클론 운영체제라 할 수 있다.Unix와 마찬가지로 다중 사용자, 다중작업 다중 스레드를 지원하는 네트워크 운영체제를 의미한다.  
또한 Unix가 애초부터 통신 네트워크를 지향해 설계된 것 처럼 Linux 역시 서버로 작동하는데 최적화 되어있다. 또한 Linux는 자유 소프트 라이센스로 누구나 소스코드를 활용, 수정 및 재 배포가 가능해서 지속적인 업그레이드가 이루어진다.

### Linux 배포판

리눅스 커널, GNU소프트웨어 및 여러가지 자유 소프트웨어로 구성된 운영체제로 현재 전 세계쩍으로 300여가지의 배포판이 존재한다. 리눅스 배포판은 사용자에 따라 결정할 수 있는 폭이 넓다.  
상용 또는 비상용 분류/ 사용자에 따른 분류/ 구동환경/용도/지원 플랫폼 차이 등 으로 나눌 수 있다.  
리눅스 배포판의 대표적인 것으로는  
회사차원에서 관리하고 배포하는 대표적인 배포판은 레드햇, 우분투, 수세가 존재, 커뮤니티차원에서 관리하는 대표적인 배포판은 데비안, 젠투, 페도라가 존재한다.

### Linux 특징
리눅스(Linux)의 주요 특징은 다음과 같습니다.

1. 오픈 소스: 리눅스는 오픈 소스 운영 체제로, 소스 코드를 누구나 자유롭게 볼 수 있고 수정할 수 있습니다. 이는 커뮤니티 기반의 개발과 유지 보수를 가능케 하며, 보안과 안정성이 높은 운영 체제를 만드는 데 큰 기여를 합니다.
2. 멀티 유저, 멀티태스킹: 리눅스는 다중 사용자 및 다중 작업 환경을 지원합니다. 여러 사용자가 동시에 컴퓨터를 사용할 수 있고, 하나의 컴퓨터에서 여러 작업을 동시에 처리할 수 있습니다.
3. 안정성: 리눅스는 운영 체제의 안정성이 높습니다. 시스템 충돌, 프로그램 충돌, 바이러스 등의 문제를 예방하고 대처할 수 있는 구조를 가지고 있습니다.
4. 보안성: 리눅스는 보안성이 높은 운영 체제입니다. 사용자 계정 분리, 파일 권한 설정, 방화벽 등의 기능을 통해 해킹 등의 공격으로부터 시스템을 보호합니다.
5. 다양한 배포판: 리눅스는 다양한 배포판으로 제공됩니다. 이러한 배포판들은 서버, 개인용 컴퓨터, 모바일 기기 등 다양한 용도에 맞게 사용할 수 있습니다.
6. 유연성: 리눅스는 유연성이 높습니다. 사용자가 필요한 기능이나 프로그램을 추가하거나 수정하여 사용할 수 있습니다.
7. 무료: 리눅스는 무료로 사용할 수 있습니다. 따라서 비용 부담 없이 운영 체제를 사용할 수 있으며, 개발 및 시스템 유지 보수 비용을 절감할 수 있습니다.


### 리눅스의 중요성

리눅스는 현재 서버, 클라우드, IoT 등 다양한 분야에서 광범위하게 사용되고 있습니다. 그 이유는 다음과 같습니다.

1. 안정성: 리눅스는 운영 체제의 안정성이 높습니다. 이는 서버 환경에서는 매우 중요한 요소이며, 비즈니스와 기관에서 사용되는 시스템에서는 안정적인 운영 체제가 필수적입니다.
2. 보안성: 리눅스는 보안성이 높은 운영 체제입니다. 이는 인터넷을 통해 연결된 서버, 클라우드 등에서 사용되는 시스템에서는 매우 중요한 요소입니다.
3. 무료: 리눅스는 무료로 사용할 수 있습니다. 이는 기업에서 사용되는 시스템의 비용을 절감할 수 있으며, 개인 사용자들도 비용 부담 없이 운영 체제를 사용할 수 있습니다.
4. 오픈 소스: 리눅스는 오픈 소스 운영 체제로, 소스 코드를 누구나 자유롭게 볼 수 있고 수정할 수 있습니다. 이는 개발자들이 필요한 기능을 추가하거나 수정하여 사용할 수 있으며, 커뮤니티 기반의 개발과 유지 보수를 가능케 합니다.
5. 다양한 배포판: 리눅스는 다양한 배포판으로 제공됩니다. 이는 서버, 개인용 컴퓨터, 모바일 기기 등 다양한 용도에 맞게 사용할 수 있습니다.
6. 유연성: 리눅스는 유연성이 높습니다. 사용자가 필요한 기능이나 프로그램을 추가하거나 수정하여 사용할 수 있습니다.

이러한 이유로 리눅스는 현재 서버 및 클라우드 시스템에서 매우 중요한 역할을 하고 있으며, 또한 IoT 분야에서도 점점 더 사용되고 있습니다. 더불어 개인용 컴퓨터에서도 점점 더 많은 사용자들이 리눅스를 사용하고 있습니다.


### 시스템 콜(System Call)
시스템 콜은 Mode bit를 기반으로 0이면 커널모드, 1이면 사용자 모드로 나뉘어서 작동한다.  사용자가 파일 생성, 프로그램 실행 등의 호출을 수행하려면 시스템 콜을 통해 서비스를 제공받을 수 있습니다.

![[Linux10.png]]

예를 들어 유저 프로그램이 I/O 요청을 하면,  trap이 발동되면서 모드비트가 1에서 0으로 변경되고, 커널에 전달됩니다. 커널은 해당 서비스를 수행하고, 다시 trap을 통해 모드비트를 0에서 1로 변경하여 사용자모드로 전달해 줍니다.

### Linux 구조

#### 부트로더
부트로더는 컴퓨터가 시작될 때 처음 실행되는 프로그램으로서,  
운영체제의 커널이 디스크의 어디에 있는지 알고 있으며 그것을 메모리로 불러오는 역할을 합니다.  
즉 쉽게 설명하자면 해당 운영체제가 부팅이 될 수 있도록 해 주는 프로그램입니다.




리눅스는 크게 커널, 셸, 디렉토리로 3가지로 구성되어 있다.  


![[Linux4.png]]


#### 커널(kernel)  
커널은 운영체제의 핵심으로 메모리관리, 프로세스 관리, 장치 관리등 컴퓨터의 모든 자원을 초기화하고 제어하는 기능을 수행한다.
컴퓨터 운영 체제의 핵심이 되는 컴퓨터 프로그램으로, 시스템의 모든 것을 완전히 통제하며, 운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러 가지의 서비스를 제공한다.  
프로그램의 실행 과정에서 가장 핵심적인 연산이 이루어지는 부분으로 코어, 리눅스라고 부른다. 
하드웨어를 직접 제어하고, 프로세스 관리, 메모리 관리, 파일 시스템 관리 등을 수행하는 운영체제의 핵심으로, 사용자가 실행시키는 응용프로그램(Application)과 하드웨어 사이의 관리자 역할을 수행하며 쉘과 연관되어 쉘에서 명령하는 작업을 수행하고 수행된 결과를 쉘로 보내는 역할을 한다.



![[Linux7.png]]



![[Linux3.png]]







- 컴퓨터 제일 내부에는 하드웨어가 있고, 이 하드웨어를 관리해주는 것이 운영체제(OS)의 핵심 커널이다.
- 하드웨어(H/W)에는 CPU, 메모리(RAM), 하드디스크(HDD), 기타 입출력 장치 등 실제 직접 조작할 수 없어 커널을 통해 시스템 자원을 효율적으로 관리한다.
- 눅스의 우분투, 센토스 등의 배포판은 리눅스 커널을 기반
- **사용자가 쉘을 통해 입력한 명령어를 해석하여 기계가 이해할 수 있는 표현으로 바꾸어 전달해주는 역할이 커널이다.**
- 일종의 OS
- C언어와 어셈블리 언어로 구성 되어 있으며 디바이스 관리와 프로세스 관리, 메모리 관리를 담당한다.
- 


![[Linux9.png]]

- **태스크(Task) 관리자**

물리적 자원인 CPU를 추상적 자원인 Task로 제공

- **메모리(Memory) 관리자** 

물리적 자원인 메모리를 추상적 자원인 Page 또는 Segement로 제공

- **파일 시스템(File System) 관리자** 

물리적 자원인 디스크를 추상적 자원인 File로 제공

- **네트워크(Network) 관리자**

물리적 자원인 네트워크 장치를 추상적 자원인 Socket으로 제공

- **디바이스 드라이버(Device Driver) 관리자**

각종 외부 장치에 대한 접근

- **Interrupt Handling**

인터럽트 핸들러

- **I/O Communication**

입출력 통신 관리




**프로세스 관리 (Process management)**  
	    -  여러 개의 프로그램이 실행될 수 있도록 프로세스들을 CPU 스케줄링하여     마치 그들이 동시에 수행되는 것처럼 보이는 효과를 낸다.  
	    - 리눅스에서는 프로그램을 실행할 때 파일 시스템 내 특정 디렉토리에 있는 프로그램의 파일을 읽어와 메모리에 적재한다. 
	    - 이 프로그램이 메모리에서 실행되는 프로세스가 된다. 프로그램이 종료된다며 프로세스 역시 삭제된다.
	    - 각 프로세스에는 PID(process id)가 부여되며 커널은 이 PID를 통해 프로세스를 관리하게 된다.
**● 파일 관리 (File management)**  
	    - 디스크와 같은 저장 장치 상에 파일 시스템을 구성하여 파일을 관리한다.  
**● 메모리 관리 (Memory management)**  
	    - 메인 메모리가 효과적으로 사용될 수 있도록 관리한다.  
	    - 사용자 프로그램의 요구에 따라 메모리 영역을 분배하거나 이용이 끝난 메모리 영역 회수 등을 담당하는 것이 커널이 수행하는 메모리 관리이다.
	    - 메모리 관리에서는 가상 메모리 또한 지원한다. 
	    - 가상 메모리라는 것은 이름에서 알 수 있듯이 실제로는 없는 메모리지만, 실제로 존재하는 것처럼 메모리를 사용할 수 있게 해준다. 
	    - 가상 메모리는 실제 메모리가 아닌 HDD와 같은 보조 기억 장치의 일부도 프로세스가 볼 때에는 같은 메모리인 것처럼 보이게 하기 때문에 실제 내장된 메모리보다 더 큰 용량이 메모리 사용이 가능하다.
		
![[Linux2.jpg]]



**● 통신 관리 (Communication management)**  
	    네트워크를 통해 정보를 주고받을 수 있도록 한다.**● 주변장치 관리 (Device management)**    모니터, 키보드, 마우스와 같은 장치를 사용할 수 있도록 관리한다.



#### 쉘(shell)  
사용자가 입력한 문장을 읽어 요청을 실행하며 커널이 명령어를 해석해 결과를 수행한 후 결과를 다른 프로그램이나 커널로 전송한다.  
즉 사용자와 커널의 중간다리 역할을 수행한다. 리눅스는 bash셸을 기본으로 사용한다.
셸은 운영체제 상에서 다양한 운영 체제 기능과 서비스를 구현하는 인터페이스를 제공하데 사용자가 입력하는 명령을 대신 해석해 커널에게 전달하여 실행해주는 프로그램이다. 쉘은 사용자가 입력한 문자열을 해석하고 해당 명령어를 찾아 커널에 작업을 요청하게 된다. 그리고 커널에서 작업을 수행한 결과를 다시 쉘로 보내면 쉘은 그 결과를 유저에게 알려주는 형식이다.  
셸은 사용자와 운영 체제의 내부 사이의 인터페이스를 감싸는 층이기 때문에 붙여진 이름이다. 셸은 일반적으로 명령 줄과 그래픽 형의 두 종류로 분류된다.

**쉘(Shell)** 은 **사용자와 운영체제 사이의 인터페이스를 제공하는 특수 프로그램으로 명령어를 입력받아 그 명령어를 해석하여 수행해 주는 명령어 해석기**입니다.

- **쉘은 커널을 사용자가 직접 제어하기는 어렵기 때문에 바로 사람이 이해하기 쉬운 형태로 명령어를 입력하면, 그 명령어로 쉘에 해당하는 프로그램들이 해석해서 커널에게 전달해 주는 것, 소프트웨어와 하드웨어간의 커뮤니케이션을 관리하는 프로그램**  
    -> **사용자(명령)-> 쉘(해석) -> 커널(명령 수행 후 결과 전송) -> 쉘(해설) -> 사용자(결과 확인)**
- 명령어 해석기 기능, 프로그래밍 기능(Shell Script), 사용자 환경 설정 기능( 파일의 권한 설정, 명령어를 찾아오는 경로 설정 등)
- 쉘은 커널을 컨트롤할 수 있으며 커널은 하드웨어를 컨트롤합니다. 즉, 하드웨어를 유저가 컨트롤하기 위한 인터페이스라고 볼 수 있습니다.


```
/bin/bash 
/bin/csh 
/bin/dash 
/bin/ksh 
/bin/sh 
/bin/tcsh 
/bin/zsh
```
- cat /etc/shells 명령어를 통해 /etc/shells 파일을 보면 현재 운영체제 환경에서 사용할 수 있는 쉘의 종류를 확인할 수 있다. bash, zsh, ksh 등 다양한 쉘의 종류가 있다.


- Bourne Shell (sh)
    - 유닉스 7버전의 기본 쉘. (본쉘)
- C Shell (csh)
    - C언어 기반으로 개발되어 프로그램 작성 기능이 좋음.
    - History, alias 등 여러 유용한 기능이 있음.
    - 명령행 편집 기능이 없음.
- TC Shell (tcsh)
    - C 쉘과 통합해서 탄생된 쉘. TC쉘이라고 불림.
    - C 쉘에 없는 명령어 자동완성, 편집기능을 지원.
- Korn Shell (ksh)
    - 본쉘을 확장해서 만들어진 쉘. C 쉘의 여러 기능이 추가됨.
    - History, vi, 명령행 편집 등 여러 기능을 제공.
- Bourne Again Shell (bash)
    - 본쉘을 기반으로 만들어진 쉘.
    - 현재 리눅스의 표준쉘.
    - GNU 프로젝트를 위해 개발되었으며 맥 OS 등 여러 운영체제에서 사용됨.
    - sh와 호환되는 문법과 history, 명령행 편집 등 다양한 기능을 가지고 있음.
- Z shell (zsh)
    - 본쉘의 확장된 버전.
    - 다양한 기능, 플러그인, 테마가 존재.
        - 맞춤법 검사.
        - 로그인 / 로그아웃 감시 기능.
        - 바이트 코드와 같은 내장 프로그래밍 기능.
        - 구문의 과학적 표기적 지원.
        - 부동 소수점 산술 및 기타 기능.

## Bash 쉘의 기본 기능들( 일부 zsh와 비교 )

---

### 명령행 자동완성 기능

- 리눅스에서 가장 많이 사용되는 기능 중 하나

- 특정 파일이나 디렉토리명이 너무 길어서 불편한 경우  글자 몇 개만 입력한 뒤 Tab을 누르면 자동완성 기능이 동작.  
    만약 해당 글자들이 포함되는 파일이 여러개 있다면 Tab을 두 번 눌러 목록을 확인할 수 있음.

예시

- bash에서 Tab을 두 번 눌러 목록을 확인한 후 한 번 눌러 자동 완성하기.

![[Linux11.gif]]







다양한 쉘의 종류가 있으며, 대부분 bash, zsh을 많이 사용한다. zsh은 bash와 동일한 쉘을 기반으로 추가 기능을 제공한다

```linux
# 사용 중인 쉘 확인 명령어들 
echo $0 
echo $SHELL 
ps | grep sh 
env | grep SHELL
```

리눅스에서 현재 사용 중인 쉘의 종류를 알아볼 수 있는 다양한 방법이다.


```
# 쉘 변경하기 
chsh -s /bin/bash sasca37
```

- chsh -s /bin/[쉘이름] [사용자명] 을 입력하면 현재 사용 중인 쉘을 변경할 수 있다.





####  프로세스 (Process)

##### 프로세스란?

- 커널의 관리 하에 **현재 시스템에서 동작 중인 모든 프로그램을 프로세스**라 합니다. 
- **모든 프로세스는 고유의 권한과 책임을 가지고**, 연산을 위해 **컴퓨팅 자원을 이용하거나 서로 통신**을 할 수 있습니다. 
- 직관적인 이름을 가진 **ps 명령어를 이용하면 현재 실행 중인 프로세스를 확인**할 수 있습니다.

##### 프로세스 구분: **동작 방식**에 의한
- Foreground process
    - 쉘/터미널에서 사용자가 입력한 명령을 해석하여 실행하고 그 결과를 출력하는 방식의 프로세스가 Foreground process입니다.
    - 입력한 명령이 **실행되어 결과가 출력될 때까지 사용자가 다른 작업을 수행할 수 없습**니다.
- Background process: 
    - Foreground process와 달리 **사용자 입력과 상관없이 실행되는 프로세스**를 말합니다. 
    - 명령의 처리가 끝나는 것과 관계없이 곧바로 터미널에 프롬프트가 출력되어 사용자가 다른 작업을 수행할 수 있습니다. 
    - 명령어의 마지막에 &을 추가하면 특정 명령을 Background process로 실행할 수 있습니다.

##### 프로세스 구분: **생성 주체**에 의한

- **Init 프로세스**: 리눅스 시스템이 부팅되면 가장 먼저 실행되는 프로세스로 파일 시스템 구조 검사, 파일 시스템 마운트, 서버 데몬 실행, 사용자를 위한 셸 실행 등의 작업을 수행합니다.
- **데몬 프로세스**: 사용자에게 **특정 기능/서비스를 제공하는 프로세스**입니다.
- **부모 프로세스**: 다른 프로세스를 생성하는 프로세스이며, init 프로세스를 제외한 모든 프로세스는 부모 프로세스를 가집니다.
- **자식 프로세스**: 부모 프로세스에 의해 생성되는 프로세스로 작업이 완료되면 부모 프로세스에게 결과를 전달한 후 종료됩니다.
- **고아 프로세스**: 부모 프로세스가 끝났는데도 불구하고 남아있는 자식 프로세스를 고아 프로세스라고 합니다.
- **좀비 프로세스**: 종료 신호를 부모 프로세스가 처리하지 못할 경우 자식 프로세스를 좀비 프로세스라고 합니다.

#### 쉘 세션(Shell session)

- 하나의 유저가 실행시킨 쉘을 의미하며 **하나의 쉘/터미널*마다 하나의 쉘 세션**만을 가질 수 있습니다.
- 만약 터미널에서 **세션 로그아웃이 발생하면 HUP(Hang UP) signal을 전달**하여 **해당 세션에서 실행된 모든 프로세스를 종료**시킵니다.
    - **터미널/콘솔**이란? **쉘을 실행하기 위한 Wrapper Program을 의미**합니다. (엄밀히 말하면 콘솔은 HW, 터미널은 SW측면에서 시스템을 조작할 수 있는 체계를 말하지만 현재는 명확한 구분 없이 사용된다고 합니다.)
        - 터미널을 실행시켰을 때 커서 앞에 있는 문자를 **Prompt**라고 하고, **쉘을 통해 명령어를 전달할 준비가 되었음을 알려주는 기능**을 합니다. ($: 보통 유저, #: 시스템 관리자)




### 커널-쉘-유틸리티의 관계

![[Linux5.png]]

- 디스크에 커널, 유틸리티, 쉘이 있다가, 부팅 시 커널이 가장 먼저 메모리에 올라감  
  

![[Linux6.png]]

- 유저A가 터미널을 켜면 커널의 프로세스에 의해 해당 터미널 위에 쉘이 메모리에 올라감  
- 유저B가 터미널을 켜면 커널의 프로세스에 의해 해당 터미널 위에 쉘이 메모리에 올라감  
- 쉘은 유저의 커맨드 입력을 기다리다, 유저B가 커맨드 입력 시(ex:ppt) 커맨드에 대응되는 유틸리티를 디스크로부터 가져와 실행(ex:ppt 실행)







### 파일시스템 계층구조(FHS- Filesystem Hierarchy Standard)

![[Linux1.gif]]




![[Linux8.png]]


|   |   |
|---|---|
|디렉터리|설명|
|/|리눅스 파일시스템의 최상위 디렉터리|
|/bin/|모든 사용자가 사용할 수 있는 주요 명령어들이 위치. ls , cp, mkdir, mv, rm, cat, tar 등|
|/boot/|커널 파일이나 initrd 등 부팅이 필요한 파일일 위치|
|/dev/|디바이스 파일이 존재하는 디렉터리|
|/etc/|Editable Text Configuration, Extended Tool Chest   <br>시스템 환경 설정 파일과 시스템 초기화 시 수행되는 스크립트 파일 위치|
|/home/|로그인한 사용자의 파일, 개인설정 등 사용자 전용 홈 디렉터리.|
|/lib/|시스템에 설치되어 있는 각종 라이브러리가 저장되어 있는 디렉터리.|
|/media/|cd-rom이나 이동식 디스크 마운트시 사용|
|/mnt/|다양한 디바이스가 마운트시 사용하는 임시 디렉터리|
|/opt/|추가 어플리케이션 소프트웨어 패키지|
|/proc/|메모리상 존재하는 모든 프로세스들이 파일 형태로 매핑. 가상 파일시스템으로 구현.|
|/root/|루트 사용자의 홈 디렉터리|
|/sbin/|shutdown, ifconfig등 root가 사용하는 시스템 관리 명령어가 포함. system Binary 약자|
|/tmp/|각종 프로그램들이 임시 파일을 생성하는 디렉터리|
|/usr/|사용자들이 사용하기 위해 설치한 주요 명령어가 위치|
|/usr/bin/|대부분의 사용자 명령어 포함|
|/usr/include/|프로그래밍 언어가 사용하는 헤더파일 위치|
|/usr/lib/|/usr/bin/ /usr/sbin/ 에 있는 바이너리에 링크하기 위한 라이브러리|
|/usr/sbin/|시스템관리자가 사용하는 명령이나 상대적으로 중요하지 않은 명령어들이 위치|
|/usr/src/|다양한 바이너리의 소스코드 위치. 커널 소스코드도 위치|
|/usr/X11R6/|X윈도우 관련 파일 위치|
|/var/|로그, 스풀 파일 등 임시로 생성되거나 상황에 따라 생성되거나 삭제될 수 있는 데이터가 보관.|



1. # shutdown -h now  
    \# halt  
    \#poweroff  
    \# init 0
2. 재부팅하는 방법  
    \# shutdown -r now  
    \# reboot  
    \# init 6
3. 예약된 시간에 시스템을 종료하거나 재시작  
    5분뒤 종료 : # shutdown -h +5  
    특정시간 종료 : # shutdown -h 10:00  
    5분뒤 재부팅 : # shutdown -r +5




리눅스의 디렉토리 구조는 전체적으로 tree 구조이며 명령어의 성격과 내용 및 사용권한 등에 따라 디렉토리로 구분된다.

~ :

- 홈 디렉토리
- 터미널 구동시 최초의 위치

/ :

- FHS의 가장 최상단 디렉토리이며 Root 디렉토리라고도 한다.
- 시스템의 근간을 이루는 가장 중요한 디렉토리로 파티션 설정 시 반드시 존재해야하며 절대경로의 기준이 되는 디렉토리이다.

/bin:

- 리눅스의 기본적인 명령어가 저장된 디렉토리
- 시스템을 운영하는데 기본적인 명령어들이 모여있다
- 서브 디렉토리가 없다.

/home:

- 사용자 홈 디렉토리, 일반 사용자의 홈 디렉토리가 만들어 지는 곳

/boot:

- 부트 설정 파일과 lilo를 제외한 부트 관련 모든 파일을 모아놓은 디렉토리

/dev:

- 시스템의 모든 디바이스를 엑세스할 수 있는 파일들을 모아놓은 디렉토리

/etc:

- 호스트의 설정 파일을 모아놓은 디렉토리

/lib:

- 시스템 부트 때 필요하거나 /bin 디렉토리 내 명령어들의 실행에 필요한 공유 라이브러리들을 모아놓은 디렉토리

/usr:

- 일반 사용자들을 위한 대부분의 프로그램 라이브러리 파일이 위치한다.
- /user/bin: 일반 사용자들이 사용가능한 명령어 파일들이 존재하는 디렉토리
- /user/local: 새로운 프로그램들이 설치되는 공간

### 디렉토리 경로

**Absolute Path**

- 이름 그대로 절대적인 경로, 완전한 경로를 의미
- Root 디렉토리부터 시작하는 경로를 뜻한다.
- 현재 나의 위치와 상관없이 항상 정확한 경로 전달

**Relative Path**

- 이름 그대로 상대적인 경로를 의미
- 현재 내 위치를 기반으로 움직인다
- .과 .. 이 두가지 심볼이 중요하다 .는 현재 디렉토리 ..는 상위 디렉토리를 의미한다.



---
참조 - https://velog.io/@ghldjfldj/%EB%A6%AC%EB%88%85%EC%8A%A4Linux%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80



https://csj000714.tistory.com/494#%EC%--%--%--%EC%--%B-%EC%--%---Shell%--session-

https://hstory0208.tistory.com/entry/kernel-%EC%9D%B4%EB%9E%80-%EC%89%BD%EA%B2%8C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90


https://sasca37.tistory.com/286


https://soopeach.tistory.com/244