# WAS




![[Was1.png]]




WAS는 틀이되는 HTML문서를 기반으로 클라이언트의 요청에 따라, 

  

실시간으로 HTML문서를 제작해 클라이언트에게 서비스 해줍니다.  

  

즉, 동적으로 웹페이지를 클라이언트에게 제공할 수 있다는 뜻입니다.

  

서버에서 HTML 제작을 도와주는 프레임워크와 프로그래밍 언어가 있습니다.

  

흔히 들어본 JAVA, JSP, Servlet, JAVA Spring, Tomcat 등이 대표적인 예입니다.

  

**( 이것들을 Web Container라고 하는데 좀 추상적인 개념이라 생략하겠습니다. )**

  

때문에 이런 작업을 하는 WAS는 일반적인 Web Server에 비해 부하가 더 많이걸리게 됩니다.

  

또한 프로그래밍 설계도 복잡해 지죠. 

(클라이언트 요청에 따라 필요한 정보를 DB에서 받아와서 특정 HTML문서 위치에 해당 데이터를 삽입하고 등....)

  

때문에 이런 설계를 모듈화 시켜 패턴을 만든 것이 MVC 모델링입니다.


# Web Server - WAS

WAS의 단점이 복잡하고 Web Server보다 느리다는 점에 있습니다.

  
또한 항상 웹페이지는 동적일 필요가 없으며 정적인 페이지도 필요합니다.

  

때문에 이 둘을 묶어 같이 사용할 수 있습니다.

  

또한 트래픽 처리함에 있어서도 WAS의 갯수를 늘려 분산처리하여 로드벨런싱 또한 가능하게 할 수 있습니다.




![[WAS2.png]]



이렇게 말이죠. 정적인 페이지 요청이 들어오면 Web Server에서 처리하고,

  

동적인 페이지 요청이 들어오면 Web Server는 해당 정보를 WAS에게 전달하죠.

  

이런식으로 분산처리를 진행한다면 트래픽을 좀 더 효율적으로 관리할 수 있게 될 것입니다.

  

하지만 서버가 모듈화 되어 분산의 형태를 띄우게 되면 서버동기화, DB동기화, 세션관리 등...

  

관리해야할 것들이 늘어나며 관리 측면에서 비용이 굉장히 증가하게 됩니다.

  

여기서 동기화란? 여러대의 서버의 데이터가 일치해야 한다는 것입니다. A. B. C. D라는 서버가 있는데,

  

A에 1234데이터가 있다면 B, C, D도 1234의 데이터를 갖고 있어야 합니다.

  

왜냐하면 여러 클라이언트가 요청 했을 때 동일한 데이터를 받아야 하는데 데이터가 일치하지 않는다면??

  

신뢰성을 잃겠죠? 정확한 데이터 전달이 목적인데 말이죠....

  

또한 분산처리 설계방식에 따라 처리하는 데이터가 아예 달라질 수도 있구요.

  

때문에 이런 것들을 해결하기 위해서 Zookeeper, Hadoop, 세션 클러스터링 등의 프로그램들을 사용하는 것입니다.












핵심은, **WAS가 멀티 스레드를 지원**한다는 것이다. 멀티스레드에 대한 부분은 WAS가 처리해준다. 즉, 개발자가 멀티스레드 관련 코드를 신경 쓰지 않아도 된다는 것이다. 마치 싱글스레드 프로그래밍을 하듯이 편하게 소스 코드를 개발하기만 하면 된다.


---
참조 - https://hwan-shell.tistory.com/288
https://trillium.tistory.com/69


https://huisam.tistory.com/entry/spring-introduce


https://escapefromcoding.tistory.com/732