



## Docker-Compose
docker-compse.yml이 있는 디렉토리로 이동
이거 같은 경우에는 docker-compose.yml 파일이 저 위치에 있기 때문에 저기로 이동 
다른곳에 있으면 다른 곳으로 이동해야함
![[Docker-Compose명령어11.png]]
![[Docker-Compose명령어6.png]]



docker-compose up 실행(이미 만들어 놓은 yml파일이 있을경우)
![[Docker-Compose명령어7.png]]

로그와 함께 실행
이때 나오고 싶을 경우 ctrl + c 입력
![[Docker-Compose명령어8.png]]

도커 지우고 싶을 때
docker-compose down

![[Docker-Compose명령어9.png]]

docker-compose up -d  도커 컴포즈 백그라운드 실행

![[Docker-Compose명령어10.png]]


결과
도커 컴포즈 안에 3개의 컨테이너 생성
![[Docker-Compose명령어12.png]]

![[Docker-Compose명령어13.png]]





# Apache

```
apache:
    image: httpd:latest
    container_name: myApache
    ports:
      - 80:80
    volumes:
      - ./apache/httpd.conf:/usr/local/apache2/conf/httpd.conf
    depends_on:
      - tomcat
```


`httpd.conf` 파일은 Apache HTTP Server (아파치 웹 서버)의 주요 구성 파일입니다. 이 파일은 웹 서버의 동작 방식, 가상 호스트 설정, 모듈 활성화, 액세스 제어 등 다양한 기능을 구성하는 데 사용됩니다.

`httpd.conf` 파일은 아파치 웹 서버의 설정을 지정하는 역할을 합니다. 몇 가지 중요한 설정을 예로 들어보겠습니다:

1. 가상 호스트 설정: `httpd.conf` 파일을 통해 가상 호스트를 구성할 수 있습니다. 가상 호스트는 동일한 서버에서 여러 개의 웹 사이트를 호스팅하는 방법을 제공합니다. 각 가상 호스트는 별도의 설정을 가지며, `httpd.conf` 파일에서 해당 가상 호스트에 대한 설정을 지정할 수 있습니다.
    
2. 모듈 활성화: 아파치 웹 서버는 다양한 모듈을 제공하여 추가 기능을 확장할 수 있습니다. `httpd.conf` 파일에서는 필요한 모듈을 활성화하고 설정할 수 있습니다. 예를 들어, SSL 모듈을 활성화하여 HTTPS 연결을 지원하거나, PHP 모듈을 활성화하여 PHP 스크립트 실행을 지원할 수 있습니다.
    
3. 액세스 제어: `httpd.conf` 파일을 사용하여 웹 서버의 액세스 제어를 구성할 수 있습니다. 예를 들어, 특정 IP 주소나 디렉토리에 대한 액세스를 허용하거나 거부할 수 있습니다. 또한, 인증과 권한 설정을 통해 접근 제한을 구성할 수도 있습니다.

### httpd.conf


```



ServerRoot "/usr/local/apache2"
Listen 80

LoadModule mpm_event_module modules/mod_mpm_event.so
LoadModule authn_file_module modules/mod_authn_file.so
LoadModule authn_core_module modules/mod_authn_core.so
LoadModule authz_host_module modules/mod_authz_host.so
LoadModule authz_groupfile_module modules/mod_authz_groupfile.so
LoadModule authz_user_module modules/mod_authz_user.so
LoadModule authz_core_module modules/mod_authz_core.so
LoadModule access_compat_module modules/mod_access_compat.so
LoadModule auth_basic_module modules/mod_auth_basic.so
LoadModule reqtimeout_module modules/mod_reqtimeout.so
LoadModule filter_module modules/mod_filter.so
LoadModule mime_module modules/mod_mime.so
LoadModule env_module modules/mod_env.so
LoadModule headers_module modules/mod_headers.so
LoadModule setenvif_module modules/mod_setenvif.so
LoadModule version_module modules/mod_version.so
LoadModule unixd_module modules/mod_unixd.so
LoadModule status_module modules/mod_status.so
LoadModule autoindex_module modules/mod_autoindex.so


<Files ".ht*">
    Require all denied
</Files>


<Directory "/usr/local/apache2/cgi-bin">
    AllowOverride None
    Options None
    Require all granted
</Directory>


<IfModule proxy_html_module>
Include conf/extra/proxy-html.conf
</IfModule>

<IfModule ssl_module>
SSLRandomSeed startup builtin
SSLRandomSeed connect builtin
</IfModule>

LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_http_module modules/mod_proxy_http.so

<VirtualHost *:80>
    ServerName localhost
    ProxyPass / http://tomcat:8080/ retry=1 acquire=3000 timeout=600
    ProxyPassReverse / http://tomcat:8080/
</VirtualHost>
```



## SSL


```

genrsa -out private.key 2048 >> private.key는 다른걸로 설정 가능 ex) pp.key

rsa -in private.key -pubout -out public.key >> public.key도 설정 가능 pb.key
req -new -key private.key -out private.csr -config C:\Users\tmdal\Downloads\openssl-1.0.2j-fips-x86_64\OpenSSL\bin/openssl.cnf >>private.csr도 다른걸로 설정 가능 pp.csr

genrsa -aes256 -out rootCA.key 2048
>>rootCA.key도 원하는 이름으로 가능

req -x509 -new -nodes -key rootCA.key -days 3650 -out rootCA.pem -config C:\Users\tmdal\Downloads\openssl-1.0.2j-fips-x86_64\OpenSSL\bin/openssl.cnf
>>rootCA.pen도 원하는 이름으로 가능 

x509 -req -in private.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out private.crt -days 3650
>>private.crt도 설정 가능 ex) pp.crt
```


 #### Common Name   지정
![[DockerSSL1.png]]


지정후 yml에서 apache volumes 추가

```
apache:
    image: httpd:latest
    container_name: myApache
    ports:
      - 80:80
      - 8443:8443
    volumes:
      - ./apache/httpd.conf:/usr/local/apache2/conf/httpd.conf
    #  - ./apache/workers.properties:/usr/local/apache2/conf/workers.properties
    #  - ./apache/htdocs:/usr/local/apache2/htdocs # war파일을 톰캣에 배포한 경우 필요 x
      - C:\Users\tmdal\Downloads\openssl-1.0.2j-fips-x86_64\OpenSSL\bin/private.crt:/usr/local/apache2/conf/server.crt
      - C:\Users\tmdal\Downloads\openssl-1.0.2j-fips-x86_64\OpenSSL\bin/private.key:/usr/local/apache2/conf/server.key
    depends_on:
      - tomcat
    command: ["httpd-foreground"]  # SSL 모듈 활성화를 위한 커맨드 추가

```



실제로 자신이 만든 키와 crt를 가져와야함


```
<VirtualHost *:8443>
    ServerName localhost
    # SSL 설정 추가
    SSLEngine on
    SSLCertificateFile /usr/local/apache2/conf/server.crt
    SSLCertificateKeyFile /usr/local/apache2/conf/server.key
    DocumentRoot /usr/local/apache2/htdocs
    ProxyPass / http://tomcat:8080/ retry=1 acquire=3000 timeout=600
    ProxyPassReverse / http://tomcat:8080/ 
</VirtualHost>
```

CN과 동일하게 ServerName 설정
- `SSLEngine on`: SSL 엔진을 활성화합니다. 이 설정은 HTTPS 연결을 사용하도록 Apache에 알려줍니다.
- `SSLCertificateFile /usr/local/apache2/conf/server.crt`: SSL 인증서 파일의 경로를 지정합니다.
- `SSLCertificateKeyFile /usr/local/apache2/conf/server.key`: SSL 인증서의 개인 키 파일의 경로를 지정합니다.


### Spring Security란?

스프링 시큐리티는 인증 (Authentication) ,권한(Authorize) 부여 및 보호 기능을 제공하는 프레임워크다.

Java / Java EE 프레임워크

개발을 하면서 보안 분야는 시간이 많이 소요되는 활동들 중 하나다. Spring Security를 사용함으로써 짜여진 내부 로직을 통해 인증, 권한 확인에 필요한 기능과 옵션들을 제공한다.

Spring Security는 Spring 기반의 애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크이다. Spring Security는 '인증'과 '권한'에 대한 부분을 Filter 흐름에 따라 처리하고 있다. 
Filter는 Dispatcher Servlet으로 가기 전에 적용되므로 가장 먼저 URL 요청을 받지만, Interceptor는 Dispatcher와 Controller사이에 위치한다는 점에서 적용 시기의 차이가 있다. 
Spring Security는 보안과 관련해서 체계적으로 많은 옵션을 제공해주기 때문에 개발자 입장에서는 일일이 보안관련 로직을 작성하지 않아도 된다는 장점이 있다.


#### 인증(Authentication) , 인가(Authorization)


![[Security4.png]]

_인증과 인가란 무엇일까? 보통 인증 절차를 거친 후 인가 절차를 진행한다._

- 인증: 해당 사용자가 본인이 맞는지를 확인하는 절차.
- 인가: 인증된 사용자가 요청된 자원에 접근가능한가를 결정하는 절차

**인증 방식**

1. credential 방식: username, password를 이용하는 방식

2. 이중 인증(twofactor 인증): 사용자가 입력한 개인 정보를 인증 후, 다른 인증 체계(예: 물리적인 카드)를 이용하여 두가지의 조합으로 인증하는 방식이다.

3. 하드웨어 인증: 자동차 키와 같은 방식

이중 Spring Security는 credential 기반의 인증을 취합니다.

- principal: 아이디 (username)  보호받는 Resource에 접근하는 대상
- credential: 비밀번호 (password)  Resource에 접근하는 대상의 비밀번호

특정 자원에 대한 접근을 제어하기 위해서는 **권한**을 가지게 된다.

특정 권한을 얻기 위해서는 유저는 인증정보(Authentication)가 필요하고 관리자는 해당 정보를 참고해 권한을 인가(Authorization)한다.

보편적으로 username - password 패턴의 인증방식을 거치기 때문에 **스프링 시큐리티는 principal - credential 패턴**을 가지게 된다.

#### Spring Security의 특징

- Filter를 기반으로 동작한다.
    - Spring MVC와 분리되어 관리하고 동작할 수 있다.
- Bean으로 설정할 수 있다.
    - Spring Security 3.2부터는 XML설정을 하지 않아도 된다.

### 🔊 서블릿과 필터

> 인증과 인가를 담당하는 코드는 기존 서비스와 함께 작성될 수 있다.  
> 하지만, 인증 및 인가 코드는 핵심 비즈니스 로직과는 전혀 관련이 없으며, 보안이 요구되는 모든 컴포넌트에   
>     같은 보안 코드를 반복할 경우, 수정했을 때 아무런 상관없는 영역까지 변경이 전파되는 상당한 큰 단점이 있다.

그렇기에 서블릿 2.3 부터는 필터라는 개념이 추가되었다. 서블릿과 유사하지만, Request와 Response를 먼저 받아  
    조작할 수 있다는 차이점이 존재한다.

스프링 MVC 는 프론트 컨트롤러 패턴을 사용하여, 요청을 처리한다.

쉽게 풀어서 설명하자면, 단 하나의 Dispatcher Servlet 을 이용하여 요청을 받고, 서비스를 추상화한다는 의미이다.

즉, 스프링에서도 필터를 그대로 사용할 수 있다

```java
@ServletComponentScan
@WebServlet(name = "loadFilter", urlPattern = {"/*"}, loadOnStartup = 1}
public class LoadFilter {
    ...
}
```


```java
@Configuration
public class WebConfig {

    @Bean
    public FilterRegistrationBean logFilter() {
        FilterRegistrationBean<Filter> filterBean = new FilterRegistrationBean<>();
        filterBean.setFilter(new LogFilter());
        filterBean.setOrder(1);
        filterBean.addUrlPatterns("/*");
        return filterBean;
    }
}
```

혹은 @ServletComponentScan 과 Filter 인터페이스를 구현한 구현체에 @WebFilter 어노테이션을 추가해주는 방법 역시  사용 가능하다.

### ✂ 스프링 인터셉터

> 서블릿은 자바 웹 표준에서 제공하나, 인터셉터는 스프링 MVC 에서만 제공하는 기능이다.  
> 서블릿과 관계없이 Dispatcher Servlet 에서 컨트롤러에 가기 전에 실행된다.  
> 즉, Spring MVC 의 핵심인 Dispatcher Servlet 에서 동작하는 모든 객체와 예외들에 접근할 수 있다.

- preHandle (boolean)
    - 컨트롤러에 가기전에 호출되는 메소드
    - 반환값이 true 이면 다음 인터셉터가 호출되고, 그렇지 않다면 컨트롤러를 바로 호출한다.
- postHandle (boolean)
    - 컨트롤러의 return 이후 호출되는 메소드
    - 뷰에 전달할 Model 를 조작할 수 있다.
- afterCompletion
    - HTML 뷰가 렌더링된 이후에 호출되는 메소드

#### ⚠ 주의할 점

> postHandle 메소드는 컨트롤러에 예외가 발생할 경우, 호출되지 않는다.  
> 반면에 afterCompletion 메소드는 예외와 상관없이 **항상** 호출된다.

### ⚔ 필터 VS 인터셉터

> 필터는 J2EE 표준 스펙에 정의되어 있는 기술이기에, Spring Framework 에 의존적이지 않다.  
> 반면, 인터셉터는 스프링에서만 사용할 수 있는 기술이다.

![[Security8.png]]

웹 애플케이션에 전역적으로 처리해야하는 기능은 필터로 처리하는 것이 좋고, 클라이언트에 들어오는 디테일한 처리는  인터셉터의 다양한 기능으로 처리하는 것이 좋다고 한다.

## 🌫 스프링 필터

> 스프링에서는 서블릿 요청이 들어오면, 스프링 컨테이너와 연결할 수 있는 DelegationFilterProxy 라는  
>     서블릿 필터를 제공한다.

DelegationFilterProxy 를 통해 스프링 빈으로 구현한 필터를 등록하고, 서블릿 표준 필터처럼 동작하게 된다.

즉, Spring Security 가 Filter 를 사용해서 구현했다는 것은 DelegationFilterProxy 를 통해 필터를 등록했다는 뜻이다.

Spring Security 는 FilterChainProxy 를 통해 다양한 필터 기능을 구현하며, 이는 스프링 빈이기에 DelegationFilterProxy 를

    통해 필터에 추가된다.

### ☄ FilterChainProxy

> Spring Security 에서 제공하는 특수 필터로 다양한 인스턴스를 SecurityFilterChain 을 통해 위임하고 있다.  
> 일종의 스프링 시큐리티를 위한 전용 Dispatcher Servlet 이라 생각하면 된다.


### SecurityFilterChain

![[Security7.png]]

스프링 시큐리티를 이용하면 개발시에 필요한 사용자의 인증, 권한, 보안 처리를 간단하지만 강력하게 구현 할 수 있다. 일반적인 웹 환경에서 브라우저가 서버에게 요청을 보내게 되면, DispatcherServlet(FrontController)가 요청을 받기 이전에 많은 ServletFilter(서블릿 필터)거치게 된다. Security와 관련한 서블릿 필터도 실제로는 연결된 여러 필터들로 구성 되어 있다. 이러한 모습때문에 Chain(체인)이라는 표현을 쓴다.


- SecurityContextPersistenceFilter
    - SecurityContextRepository 에서 SecurityContext 를 조회 및 저장
    - Authentication 객체를 보관하는 시큐리티 컨텍스트를 생성하는 필터
- LogoutFilter
    - 설정된 로그아웃 URL 로 오는 요청을 감시 및 해당 유저 로그아웃 처리
- UsernamePasswordAuthenticationFilter
    - Form 기반 인증에서 설정된 로그인 URL 로 오는 요청을 감시 및 유저 인증 처리
    - AuthenticationManager 를 통한 인증
    - 인증 성공시, 얻은 Authentication 객체를 SecurityContext 에 저장, AuthenticationSuccessHandler 실행
    - 인증 실패시, AuthenticationFailureHandler 실행
- DefaultLoginPageGeneratingFilter
    - 인증을 위한 로그인 폼 URL 감시
- BasicAuthenticationFilter
    - HTTP 기본 인증 헤더를 감시 및 처리
- RequestCacheAwareFilter
    - 로그인 성공 후, 원래 요청 정보를 제구성하기 위해 사용된다.
- SecurityContextHolderAwareRequestFilter
    - HttpServletRequestWrapper 를 상속한 SecurityContextHolderAwareRequestWrapper 클래스로  
            HttpServletRequest 정보를 감싼다.
    - SecurityContextHolderAwareRequestWrapper 는 필터 체인에게 다음 필터들에게 정보를 제공한다.
- AnonymousAuthenticationFilter
    - 사용자 정보가 인증되지 않았다면, 인증 토큰에 사용자가 익명 사용자로 나타난다.
- SessionManagementFilter
    - 인증된 사용자와 관련된 모든 세션을 추적한다.
- ExceptionTranslationFilter
    - 보호된 요청을 처리하는 도중, 발생할 수 있는 예외를 위임 및 전달한다.
- FilterSecurityInterceptor
    - AccessDecisionManager 로써 권한 부여 처리를 위임하여 접근 제어를 쉽게 해준다.
- CorsFilter
	- 허가된 사이트나 클라이언트의 요청인지 검사하는 필터
- CsrfFilter
	- CSRF 공격을 방어하는 필터
- BearerTokenAuthenticationFilter 
	- JWT 인증 필터
- RememberMeAuthenticationFilter 
	- RememberMe 쿠키를 검사하여 인증하는 필터
- HeaderWriterFilter 
	- 응답(Response)에 시큐리티와 관련된 헤더를 설정하는 필터
- WebAsyncManagerIntegrationFilter 
	- 비동기 기능을 사용할때 시큐리티 컨텍스트를 사용할 수 있도록 해주는 필터
### Spring Security Architecture(구조)

![[Security1.png]]

이 사진은 스프링 시큐리티의 아키텍처 사진이고 스프링 시큐리티의 흐름은 아래와 같다.

**1. Http Request 수신** 

-> 사용자가 로그인 정보와 함께 인증 요청을 한다.

**2. 유저 자격을 기반으로 인증토큰 생성** 

-> AuthenticationFilter가 요청을 가로채고, 가로챈 정보를 통해 UsernamePasswordAuthenticationToken의 인증용 객체를 생성한다.

**3. FIlter를 통해 AuthenticationToken을 AuthenticationManager로 위임**

-> AuthenticationManager의 구현체인 ProviderManager에게 생성한 UsernamePasswordToken 객체를 전달한다.

**4. AuthenticationProvider의 목록으로 인증을 시도**

-> AutenticationManger는 등록된 AuthenticationProvider들을 조회하며 인증을 요구한다.

**5. UserDetailsService의 요구**

-> 실제 데이터베이스에서 사용자 인증정보를 가져오는 UserDetailsService에 사용자 정보를 넘겨준다.

**6. UserDetails를 이용해 User객체에 대한 정보 탐색**

-> 넘겨받은 사용자 정보를 통해 데이터베이스에서 찾아낸 사용자 정보인 UserDetails 객체를 만든다.

**7. User 객체의 정보들을 UserDetails가 UserDetailsService(LoginService)로 전달**

-> AuthenticaitonProvider들은 UserDetails를 넘겨받고 사용자 정보를 비교한다.

**8. 인증 객체 or AuthenticationException**

-> 인증이 완료가되면 권한 등의 사용자 정보를 담은 Authentication 객체를 반환한다.

**9. 인증 끝**

-> 다시 최초의 AuthenticationFilter에 Authentication 객체가 반환된다.

**10. SecurityContext에 인증 객체를 설정**

-> Authentication 객체를 Security Context에 저장한다.

최종적으로는 SecurityContextHolder는 세션 영역에 있는 SecurityContext에 Authentication 객체를 저장한다. 사용자 정보를 저장한다는 것은 스프링 시큐리티가 전통적인 세선-쿠키 기반의 인증 방식을 사용한다는 것을 의미한다.



