# 도커란?

Go언어로 작성된 리눅스 컨테이너 기반으로 하는 오픈소스 가상화 플랫폼이다.

다시 말해 특정한 서비스를 패키징하고 배포하는데 유용한 오픈소스 프로그램이다.

> 가상화란?
> 	가상화란 물리적 자원인 하드웨어를 효율적으로 활용하기 위해서 하드웨어 공간 위에 가상의 머신을 만드는 기술이고, 컨테이너란 컨테이너가 실행되고 있는 호스트 os의 기능을 그대로 사용하면서 프로세스를 격리해 독립된 환경을 만드는 기술을 뜻합니다.


 도커는 **독립된 환경을 만들어서 하드웨어를 효율적으로 활용하는 기술**
 
도커는 컨테이너 기반의 가상화 플랫폼입니다. 부두에서 컨테이너를 옮기고 관리하는 직업인 `docker`에서 따 온 이름에 걸맞게 컨테이너를 잘 다룰 수 있게 도와 주는 도구라고 할 수 있다.
도커를 이용하면 이미지를 실행시켜 컨테이너로 만들거나, 생성된 컨테이너를 관리하거나, 컨테이너를 다시 이미지로 만드는 작업을 쉽게 할 수 있습니다.

도커는 아주 강력한 도구.
개발 과정에서 다른 라이브러리와 충돌하는 것을 방지하기 위해 격리된 환경이 필요할 때, 완성된 서비스를 배포할 때, 혹은 배포 중인 서비스를 받아서 실행해 볼 때도 유용하다. 
특히 배포 과정에서 도커를 사용해 필요한 파일들만 예쁘게 포장해서 이미지로 만들면 지긋지긋한 종속성 이슈에서 벗어날 수 있다. 
서버 한 대에만 배포한다면 종속성은 큰 문제가 되지 않겠지만, 서버가 2대, 4대, 8대... 수백, 수천 대까지 늘어난다면  _파일 받고, 필요한 라이브러리 설치하고, 앗! 이거 먼저 설치해야 하는데..._ 도커를 사용하면 그냥 같은 이미지를 실행해서 컨테이너로 만들면 된다. 

도커는 일반적으로 도커 엔진(Docker Engine) 혹은 도커에 관련된 모든 프로젝트를 말합니다.

> 도커 엔진(Docker Engine)
> 컨테이너를 생성하고 관리하는 주체로서 이 자체로도 컨테이너를 제어할 수 있고 다양한 기능을 제공하는 도커의 프로젝트입니다. 
> 도커의 생태계에 있는 여러 프로젝트들은 도커 엔진을 좀 더 효율적으로 사용하기 위한 것에 불과하기 때문에 도커의 핵심은 도커 엔진이라고 할 수 있습니다.






![[Docker1.png]]



컨테이너에는 라이브러리, 시스템 도구, 코드, 런타임 등 소프트웨어를 실행하는데 필요한 모든 것이 포함되어 있다.

가상 머신에 비해 꼭 필요한 것만 담겨서 구동되기 때문에 이미지를 만들 경우 용량이 대폭 줄어들게 된다.

>도커를 왜 사용할까?
>1. 애플리케이션 독립성을 가진다. 호스트 OS, 다른 컨테이너와도 독립된 공간을 보장받아 충돌이 발생하지 않는다.
>
>2. 컨테이너 내부에 작업 후 배포하려 한다면 도커 이미지로 만들어서 운영서버에 전달만 하면 된다.
>
>3. 마이크로 서비스 구조로 변화가 쉽다. 컨테이너 하나당 하나의 기능을 제공하는 모듈로 만드는 등 조정이 가능하다.


다시 말해, Docker을 사용하면 환경에 구애받지 않고 애플리케이션을 신속하게 배포, 확장할 수 있다.


### 가상화와 컨테이너


가상화와 컨테이너에 대해 조금 더 이야기해 볼까요? 앞서 가상화는 하나의 하드웨어를 여러 개의 가상 머신으로 분할해 효율적으로 사용할 수 있는 기술이라고 언급했는데요, 분할된 가상 머신들은 각각 독립적인 환경으로 구동됩니다. 이 때 베이스가 되는 기존의 환경을 `Host OS`, 그리고 가상 머신으로 분할된 각각의 환경을 `Guest OS`라고 부릅니다.
![[Docker3.png]]

가상 머신을 생성하기 위해서는 하이퍼바이저 또는 가상 머신 모니터라고 불리는 소프트웨어를 이용합니다. 하이퍼바이저는 호스트 하드웨어에 설치되어 호스트와 게스트를 나누는 역할을 하고, 각각의 게스트는 하이퍼바이저에 의해 관리되며 시스템 자원을 할당받게 됩니다. 이 때 하이퍼바이저에 의해 생성된 게스트는 호스트나 다른 게스트와 상호 간섭하지 않고 완전히 분리된 환경에서 구동됩니다. 하이퍼바이저를 활용하면 마치 하드웨어가 여러 개인 것처럼 하나의 서버를 여러 명이 나눠 쓸 수도 있고, 컴퓨터 한 대에서 서로 다른 OS를 동시에 사용할 수도 있습니다.

하지만 가상 머신으로 무언가 하려면 반드시 하이퍼바이저를 거쳐야 하기 때문에 속도 저하가 필연적입니다. 또 가상 머신은 해당 환경을 구동하는 데 필요한 파일을 모두 포함하고 있기 때문에, 가상 머신을 배포할 때 만들어지는 이미지의 크기가 매우 커진다는 한계점이 있습니다.

  
하이퍼바이저와 달리 컨테이너는 가상의 OS를 만드는 것은 아닙니다. 컨테이너는 베이스 환경의 OS를 공유하면서 필요한 프로세스만 격리하는 방식으로, 커널을 공유하기 때문에 호스트 OS의 기능을 모두 사용할 수 있습니다. 그렇기 때문에 컨테이너 위에서는 호스트 OS와 다른 OS를 구동할 수 없습니다. 대신 격리시킬 애플리케이션과 거기에 필요한 파일이나 특정 라이브러리 등 종속 항목만 포함하기 때문에 배포를 위해 생성되는 이미지의 용량이 작아진다는 장점이 있습니다. 운영체제가 아닌 프로세스이며, 하이퍼바이저를 거칠 필요가 없어 실행 속도가 빠르기도 하고요.

> 이미지는 가상 머신이나 컨테이너 또는 프로그램을 실행하는 데 필요한 파일과 라이브러리, 설정 등을 가지고 있는 파일입니다. 이미지는 레이어라는 계층 구조로 이루어져 있는데, 변경 사항이 생기면 새로운 레이어를 추가해서 기록합니다. 이미지 전체를 새로 받지 않고 해당 레이어만 받는 것으로 이미지를 업데이트할 수 있다는 장점이 있지요.  
>   
> 이미지를 실행하면 프로세스, 즉 컨테이너가 됩니다.


**- 가상머신은 Hypervisor를 통해 여러개의 운영체제를 생성되고 관리됨. (Guest OS)**

**- 시스템 자원을 가상화하고 독립된 공간을 생성하는 작업은 HyperVisor를 거치므로** -> `성능 손실이 큼 ↑`

**- 가상머신은 Guest OS를 사용하기 위한 라이브러리, 커널 등을 포함하므로** -> `배포할 때 용량이 큼 ↑`



 **도커 컨테이너는 가상화된 공간을 생성할 때 리눅스 자체 기능을 사용하여 프로세스 단위의 격리 환경을 만드므로** -> `성능 손실 없음 無`

**- 가상머신과 달리 커널을 공유해서 사용하므로, 컨테이너에는 라이브러리 및 실행파일만 있으므로** -> `용량이 작음 ↓`

**- 위의 이유로 -> 컨테이너를 이미지로 만들었을 때**

 `배포하는 시간이 가상 머신에 비해 빠르며 ↑, 사용할 때의 성능 손실 또한 거의 없음 ↓`





## 도커 이미지, 컨테이너란?


_도커 이미지란? :_

**Docker Image**란 컨테이너를 실행할 수 있는 실행파일, 설정 값들을 가지고 있는 것으로,

더 이상 의존성 파일을 컴파일하거나 이것저것 설치할 필요가 없는 상태의 파일을 의미한다.

Image를 컨테이너에 담고 실행시키면 해당 프로세스가 동작한다.

_도커 이미지의 생성 방식:_

도커 이미지는 기존 이미지에 추가적인 구성이 필요할 때 다시 다운로드하는 방법이 아닌

기존이미지에 레이어를 추가하여 구성을 올려주는 방식으로 생성된다.

다시 말해, 이미지는 여러 개의 읽기 전용 레이어로 구성되고 파일 추가되면 새로운 레이어가 생성되어 추가된다.

도커는 여러 개의 레이어를 묶어 하나의 파일시스템으로 사용할 수 있게 해 준다.

_이미지와 컨테이너의 차이 :_


![[Docker2.png]]


간단하게 설명하면 도커 이미지는 설계서, 컨테이너는 설계서로 만들어진 상품이다.

게다가 이미지가 중간에 바꾸게 되더라도 기존 컨테이너는 더 이상 이미지에 영향을 받지 않는다.

_컨테이너의 정의 및 특징 :_

다시 말해 **Docker container**란 이미지를 실행한 상태로 응용프로그램의 종속성과 함께 응용프로그램 자체를 

패키징 Or 캡슐화하여 격리된 공간에서 프로세스를 동작시키는 기술이다.

  _특징_

- 컨테이너는 이미지 레이어에 읽기/쓰기 레이어를 추가하는 것으로 생성됨
- 종료되었다고 해도 삭제되지 않음 -> 읽기/쓰기 레이어 보존
- 컨테이너를 삭제한 것은 생성파일이 사라지는 것
- 한 서버는 여러 개의 컨테이너를 가져도 상관없으며 독립적으로 실행
- 컨테이너는 커널 공간과 호스트 os자원을 공유

## 도커 파일

Doker File은 이미지 생성 출발점으로 이미지를 구성하기 위한 명령어들을 작성하여 이미지를 구성할 수 있다.

다시 말해, 만들 이미지에 대한 정보를 기술한 템플릿이라고 보면 된다.

이를 빌드하면 자동으로 이미지가 생성된다. 그러므로 도커 파일을 통해 애플리케이션 빌드 및 배포를 자동화할 수 있다.

```java
FROM python:3.8.3-alpine
ENV PYTHONUNBUFFERED 1

RUN mkdir /app
WORKDIR /app

# dependencies for psycopg2-binary
RUN apk add --no-cache mariadb-connector-c-dev
RUN apk update && apk add python3 python3-dev mariadb-dev build-base && pip3 install mysqlclient && apk del python3-dev mariadb-dev build-base

RUN apk add linux-headers libffi-dev musl-dev
RUN apk add --no-cache python3-dev libffi-dev gcc

# By copying over requirements first, we make sure that Docker will cache
# our installed requirements rather than reinstall them on every build
COPY requirements.txt /app/requirements.txt
RUN pip install -r requirements.txt

# Now copy in our code, and run it
COPY . /app/
```


## 도커 구성요소


`Docker Client` -> 도커를 설치하면 그것이 Client며 build, pull, run 등의 도커 명령어를 수행합니다.

`DOCKER_HOST` -> 도커가 띄워져있는 서버를 의미합니다. DOCKER_HOST에서 컨테이너와 이미지를 관리하게 됩니다.

`Docker daemon` -> 도커 엔진입니다.

`Registry` -> 외부(remote) 이미지 저장소입니다. 다른 사람들이 공유한 이미지를 내부(local) 도커 호스트에 pull할 수 있습니다. 이렇게 가져온 이미지를 run하면 컨테이너가 됩니다.

- **public 저장소:** Docker Hub, QUAY 
- **private 저장소:** AWS ECR 혹은 Docker Registry를 직접 띄워서 비공개로 사용하는 방법등이 존재합니다.








---
참조 -  https://squirmm.tistory.com/entry/Docker-%EB%8F%84%EC%BB%A4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80#--%--%EB%-F%--%EC%BB%A-%--%EC%-D%B-%EB%AF%B-%EC%A-%--%-C%--%EC%BB%A-%ED%--%-C%EC%-D%B-%EB%--%--%--%EB%-E%--%-F


