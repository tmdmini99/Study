## **정규화란?**

- 정규화는 데이터의 일관성, 최소한의 데이터 중복, 최소한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정이다.
- 정규화된 모델은 테이블이 분해된다. 테이블이 분해되면 직원 테이블과 부서 테이블 간에 부서코드로 조인(join)을 수행하며 하나의 합집합으로 만들 수 있다.
- 정규화를 하면 불필요한 데이터를 입력하지 않아도 되기 때문에 **중복 데이터가 제거**된다.

-  관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업
- 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해하는 과정
- 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다


#### 정규화의 장점과 단점

- 장점
    - DB 변경시 이상현상(Anomaly) 제거
    - 저장 공간의 최소화 (용량 감소)
    - 데이터 구조의 안정성 및 무결성 유지
    - 데이터 삽입, 삭제 및 수정 시 테이블의 재구성 필요성 감소
- 단점
    - 릴레이션 간의 JOIN 연산 증가로 인해 응답 시간 저하



## **정규화 절차**

![[정규화1.png]]

![[정규화2.png]]

정규화는 1 정규화 ~ 6 정규화 까지 여러 과정이 존재하지만, 실제로 보통 1 ~ 3 정규화까지의 과정을 거치게 된다고 합니다.




#### 제1정규화 (First Normal Form)

- 제1정규화란
    - 테이블의 칼럼이 원자값(Atomic value, 하나의 값)을 갖도록 테이블을 분해하는 것
- 제1정규화를 만족하지 못하는 예


![[제1정규화1.png]]


![[제1정규화3.png]]



- 제1정규화를 진행한 테이블


![[제1정규화2.png]]

![[제1정규화4.png]]


- 한 칼럼에는 하나의 값만 있어야함


#### 제2정규화 (Second Normal Form)

- 제1정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것
    - 완전 함수 종속이란?
        - 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미함
- 제2정규형을 만족하지 못하는 예시


![[제2정규화1.png]]

![[제2정규화2.png]]

위의 테이블에서 기본키는 (학생번호, 강좌이름)으로 복합키 입니다.  
그리고 (학생번호, 강좌이름)인 기본키는 강의실을 결정하고 있습니다. (학생번호, 강좌이름) → (강의실)  
그런데 여기서 강의실이라는 컬럼은 기본키의 부분집합인 강좌이름에 의해 결정될 수 있습니다. (강좌이름) → (강의실)  
또한 성적이라는 컬럼은 기본키의 부분집합인 학생번호에 의해 결정될 수 있습니다. (학생번호) → (성적)  
그렇기 때문에 위의 테이블의 경우 다음과 같이 기존의 테이블에서 강의실을 분해하여 별도의 테이블로 관리하여   
제2 정규형을 만족시킬 수 있습니다.




- 제2정규화를 진행한 테이블


![[제2정규화3.png]]



![[제2정규화4.png]]



#### 제3정규화 (Third Normal Form)

- 제2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것
    - 이행적 종속이란?
        - A → B, B → C 가 성립할 때, A → C가 성립되는 것을 의미
        - 일반 속성이 다른 일반 속성에 종속되는 것
- 제3정규형을 만족하지 못하는 예시


![[제3정규화1.png]]


![[제3정규화2.png]]



- 제3정규화를 진행한 테이블  
    ('매장정보'와 '판매량'으로 테이블 분해)


![[제3정규화3.png]]


![[제3정규화4.png]]


위의 테이블에서 학생번호는 강좌이름을 결정하고 있고, 강좌이름은 수강료를 결정하고 있습니다.  
그렇기 때문에 (학생번호, 강좌이름) 테이블과, (강좌이름, 수강료)테이블로 분해해야 합니다.  
이행적 함수 종속을 제거하는 이유는 간단합니다.예를 들면 501번 학생이 강좌를 스포츠경영학으로 변경하였다고 하였을 때,  
이행적 함수 종속이 존재한다면 501번 학생은 스포츠경영학이라는 강좌를 20000원이라는 수강료로 듣게 됩니다.  
물론 수강료를 직접 바꿀 수 있지만, 이러한 번거로움을 해결하기 위해 제3 정규화를 하는 것입니다.





#### BCNF 정규화

BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것입니다.


![[BCNF정규화1.png]]


특강수강 테이블에서 기본키는 (학생번호, 특강이름)입니다. 그리고 (학생번호, 특강이름)은 교수를 결정하고 있습니다.  
또한 여기서 교수는 특강이름을 결정하고 있습니다.   
그런데 문제는 교수가 특강이름을 결정하는 결정자이지만, 후보키가 아니라는 점 입니다. 그렇기 때문에 BCNF 정규화를   
만족시키기 위해서 위의 테이블을 분해해야 하는데, 아래와 같이 특강신청 테이블과 특강교수 테이블로 분해할 수 있습니다.


![[BCNF정규화2.png]]









### **정규화의 문제점**

- 정규화는 데이터 조회(select) 시에 조인(join)을 유발하기 때문에 CPU와 메모리를 많이 사용한다.
- 아래 코드를 프로그램화 한다면 중첩된 루프(Nested Loop)를 사용해야 한다.

```sql
[ANSI JOIN}
select 사원번호, 부서코드, 부서명, 이름, 전화번호, 주소
from 직원, 부서
where 직원.부서코드 = 부서.부서코드;

select 사원번호, 부서코드, 부서명, 이름, 전화번호, 주소
from 직원 inner join 부서 on직원.부서코드=부서.부서코드;
```

### **정규화를 사용한 성능 튜닝**

- 조인으로 인하여 성능이 저하되는 문제를 반정규화로 해결할 수 있다.
- 반정규화는 데이터를 중복시키기 때문에 또 다른 문제점을 발생시킨다.


## **반정규화란?**

- 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다.
- 반정규화는 **조회(select) 속도를 향상**시키지만, 데이터 **모델의 유연성은 낮아**진다.
- 의도적으로 정규화 원칙을 위배하는 행위
- 조회 성능을 향상 시키기 위해 데이터 중복을 허용하거나 데이터를 그룹핑 하는 과정
- 정규화가 끝난 후 성능 이슈가 있을 때 가지는 과정이며, 정규화처럼 일정한 규칙 존재
- 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정


### **반정규화를 수행하는 이유**

- 정규화에 충실하여 종속성, 활용성은 향상 되었지만 수행속도가 느려진 경우
- 다량의 범위를 자주 처리해야하는 경우
- 특정 범위의 데이터만 자주 처리하는 경우
- 요약/집계 정보가 자주 요구되는 경우
- 테이블의 조인 연산을 지나치게 사용하여 데이터를 조회하는 것이 기술적으로 어려운 경우


#### 반정규화의 장점과 단점

- 장점
    - 데이터를 빠르게 조회할 수 있음
    - 조인을 제거하기 때문에 검색 시간이 최적화
- 단점
    - 데이터의 삽입, 삭제, 수정 등 갱신 시 비용이 높아짐
    - 데이터간의 일관성이 깨질 수 있음 (서로 다른 데이터가 저장될 수 있음)
    - 많은 저장 공간이 필요함


### **반정규화** **절차**


![[반정규화.png]]


**[Clustering?]**

- 클러스터링 인덱스라는 것은 인덱스 정보를 저장할 때, 물리적으로 정렬해서 저장하는 방법이다.
- 따라서 조회 시 인접 블록을 연속적으로 읽기 때문에 성능이 향상된다.

### **반정규화 기법**


![[반정규화3.png]]





#### 테이블 반정규화



![[반정규화1.jpg]]



**계산된 컬럼 추가**

- 배치 프로그램으로 총판매액, 평균잔고, 계좌평가를 미리 계산하고 그 결과를 특정 칼럼에 추가한다.

**테이블 수직 분할**

- 하나의 테이블의 두 개 이상의 테이블로 분할한다. 즉, 칼럼을 분할하여 새로운 테이블을 만드는 것이다.
![[반정규화9.png]]

**테이블 수평분할**

- 하나의 테이블에 있는 값을 기준으로 테이블을 분할하는 방법이다.
![[반정규화5.png]]




![[반정규화10.png]]





```
[Partition]
- 데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있다. 
- 파티션을 사용하면 논리적으로는 하나의 테이블이지만, 여러 개의 데이터 파일에 분산되어 저장된다. 
- Range Partition: 데이터 값의 범위를 기준으로 파티션을 수행한다. 
- List Partition: 특정한 값을 지정하여 파티션을 수행한다. 
- Hash Partition: 해시 함수를 적용하여 파티션을 수행한다. 
- Composite Partition: 범위와 해시를 복합적으로 사용하여 파티션을 수행한다. 
```



![[반정규화7.png]]










- **테이블 추가**
	- 중복 테이블 추가 : 동일한 테이블 구조를 중복하여 원격조인을 제거
    - 통계 테이블 추가 : SUM, AVG 등을 미리 수행하여 계산
    - 이력 테이블 추가 : 마스터 테이블에서 자주 조회되는 레코드를 중복하여 테이블 추가
    - 부분 테이블 추가 : 자주 이용하는 칼럼을 모아놓은 별도의 테이블 추가






### **테이블 병합**

- 1:1 관계의 테이블을 하나의 테이블로 병합해서 성능을 향상시킨다.
- 1:N 관계의 테이블을 병합하여 성능을 향상시킨다. 하지만 많은 양의 데이터 중복이 발생한다.
- 슈퍼 타입과 서브 타입 관계가 발생하면 테이블을 통합하여 성능을 향상시킨다.





![[반정규화11.png]]






```
[Super type과 Sub type]
- 슈퍼타입과 서브타입의 관계는 배타적 관계와 포괄적 관계가 있는데, 
	배타적 관계는 고객이 개인이거나 법인고객인 경우를 의미한다.
- 포괄적인 관계는 고객이 개인고객일 수도 있고 법인고객일 수도 있는 것이다.
```

**슈퍼 타입 및 서브 타입 변환 방법**


![[슈퍼타입 및 서브 타입 변환방법.png]]



![[반정규화8.png]]



![[반정규화6.png]]

_***파티셔닝**_

파티션 기법으로 테이블을 분할할 수도 있다. 파티션을 사용하면 **논리적으로는 한 테이블이지만 여러 개의 데이터 파일에 분산되어 저장**된다. 데이터값의 범위를 기준으로 하는 Range 파티션, 특정 값을 지정하는 List 파티션, 해시함수를 적용하는 Hash 파티션, 범위와 해시를 복합적으로 사용하는 Composite 파티션이 있다. 

파티션 테이블의 장점은 다음과 같다.

- 데이터 조회 시 액세스 범위가 줄어 성능이 향상된다 
- 데이터가 분할되어 있어 I/O 성능이 향상된다
- 각 파티션을 독립적으로 백업하거나 복구할 수 있다




####  속성 반정규화

- `중복 칼럼 추가` : 조인 감소를 위해 중복된 칼럼을 추가
- `파생 칼럼 추가` : 미리 값을 계산하여 칼럼에 보관
- `이력 테이블 칼럼 추가` : 대량의 이력 데이터를 처리할 때 기능성 칼럼(최근값 여부, 시작과 종료일자 등)을 추가
- `PK에 의한 칼럼 추가` : 여러 칼럼으로 이루어진 PK를 가진 테이블을 조인할 경우 단순성을 위해서 인공키를 PK로 지정하고 활용
- `응용시스템 오작동을 위한 칼럼 추가` : 이전 데이터를 임시적으로 중복하여 보관

![[반정규화3.jpg]]





####  관계 반정규화

- `중복 관계 추가` : 여러 경로를 거쳐 조인 할 수 있지만, 성능 저하를 예방하기 위해 추가적인 관계를 맺음

![[반정규화2.png]]






---

참조 - https://sodayeong.tistory.com/106

https://dev-coco.tistory.com/62

https://seaforest76.tistory.com/28
